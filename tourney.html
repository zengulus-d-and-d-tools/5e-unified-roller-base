<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified Bracket v4.2 (True Double Elim)</title>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e1e;
            --node-bg: #252525;
            --node-hover: #303030;
            --accent: #00bcd4; /* Cyan */
            --accent-dim: rgba(0, 188, 212, 0.15);
            --gold: #ffc107;
            --text-main: #eee;
            --border: #333;
            --connector: #555;
            --node-h: 46px; /* Compact height */
        }

        body { 
            font-family: 'Segoe UI', Roboto, sans-serif; 
            background: var(--bg); color: var(--text-main); 
            margin: 0; height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
        }

        /* TOOLBAR */
        #toolbar {
            height: 48px; background: var(--panel); border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            z-index: 100;
        }
        .title { font-weight: 700; color: var(--accent); letter-spacing: 1px; font-size: 0.9rem; }
        .btn { 
            background: transparent; border: 1px solid #444; color: #aaa; 
            padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; 
        }
        .btn:hover { border-color: var(--accent); color: var(--accent); }
        .btn-p { background: var(--accent); color: #000; border: none; font-weight: bold; }

        /* SETUP MODAL */
        #setup-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 999;
            display: flex; align-items: center; justify-content: center;
        }
        .modal-box {
            background: var(--panel); width: 360px; padding: 25px; border-radius: 8px;
            border: 1px solid var(--border);
        }
        textarea { 
            width: 100%; height: 120px; background: #000; border: 1px solid #333; 
            color: #ddd; padding: 10px; margin: 15px 0; font-family: monospace; box-sizing: border-box;
        }

        /* MAIN STAGE */
        #stage {
            flex: 1; position: relative; overflow: hidden; /* We scale to fit, so no scroll needed usually */
            display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }

        #bracket-root {
            transform-origin: center center;
            transition: transform 0.3s ease;
            display: flex; flex-direction: column; gap: 30px; align-items: center;
            padding: 40px;
        }

        /* BRACKET LAYOUT GRID */
        .wb-container { display: flex; gap: 60px; align-items: center; }
        .lb-container { display: flex; gap: 60px; align-items: flex-start; margin-top: 10px; border-top: 1px dashed #333; padding-top: 20px; }
        
        .side-col { display: flex; gap: 40px; }
        .side-col.right { flex-direction: row-reverse; }

        .round-group { display: flex; flex-direction: column; justify-content: space-around; min-width: 160px; }
        
        /* NODES */
        .node {
            height: var(--node-h); background: var(--node-bg); border: 1px solid var(--border);
            border-radius: 4px; display: flex; flex-direction: column; justify-content: center;
            position: relative; cursor: pointer; transition: 0.2s; 
            margin: 5px 0;
        }
        .node:hover { background: var(--node-hover); border-color: var(--accent); transform: scale(1.05); z-index: 10; }
        
        .node-id { position: absolute; top: -7px; right: 5px; font-size: 0.5rem; color: #555; background: var(--node-bg); padding: 0 3px; }

        .p-row { display: flex; justify-content: space-between; padding: 0 6px; font-size: 0.7rem; line-height: 1.4; }
        .p-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 110px; color: #bbb; }
        .p-sc { width: 14px; text-align: center; font-weight: bold; color: #444; }

        .win .p-name { color: var(--accent); font-weight: bold; }
        .win .p-sc { color: var(--accent); }
        .lose .p-name { text-decoration: line-through; opacity: 0.4; }

        /* SPECIAL NODES */
        .gf-node { 
            border: 1px solid var(--gold); box-shadow: 0 0 15px rgba(255,193,7,0.1); 
            height: 60px; width: 180px;
        }
        .gf-node .p-name { font-size: 0.85rem; max-width: 140px; }
        
        .lb-final-node {
            border: 1px solid #777; width: 180px;
        }

        /* CONNECTORS (CSS pseudo-elements) */
        /* Left WB Connectors */
        .side-col.left .node::after {
            content: ''; position: absolute; right: -42px; top: 50%; width: 40px; height: 1px; background: var(--connector); z-index: -1;
        }
        /* Right WB Connectors */
        .side-col.right .node::after {
            content: ''; position: absolute; left: -42px; top: 50%; width: 40px; height: 1px; background: var(--connector); z-index: -1;
        }
        
        /* Center Column Layout */
        .center-stack { display: flex; flex-direction: column; gap: 40px; align-items: center; justify-content: center; }

        /* SCORE MODAL */
        #score-overlay {
            display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1000;
            align-items: center; justify-content: center; backdrop-filter: blur(4px);
        }
        #score-overlay.active { display: flex; }
        .score-card { background: #222; border: 1px solid var(--accent); padding: 20px; width: 300px; border-radius: 8px; }
        .sc-row { display: flex; justify-content: space-between; align-items: center; background: #111; padding: 10px; margin-bottom: 10px; border-radius: 5px;}
        .sc-inp { background: transparent; border: none; color: #fff; font-size: 1.5rem; width: 40px; text-align: center; }
        .btn-adj { width: 30px; height: 30px; background: #333; color: #fff; border:none; border-radius: 3px; cursor: pointer; }
    </style>
</head>
<body>

<div id="setup-modal">
    <div class="modal-box">
        <h3 style="margin-top:0; color:var(--accent)">16-Player Double Elim</h3>
        <p style="color:#777; font-size:0.8rem">Enter names (one per line). Order will be randomized.</p>
        <textarea id="pInput" placeholder="P1&#10;P2&#10;..."></textarea>
        <button class="btn btn-p" style="width:100%" onclick="generate()">Create Bracket</button>
    </div>
</div>

<div id="toolbar">
    <div class="title">UNIFIED v4.2</div>
    <div>
        <button class="btn" onclick="autoFit()">Fit Screen</button>
        <button class="btn" onclick="resetAll()">New</button>
    </div>
</div>

<div id="stage">
    <div id="bracket-root">
        
        <div class="wb-container">
            <div class="side-col left" id="wb-left"></div>
            
            <div class="center-stack">
                <div style="color:var(--gold); font-size:0.7rem; letter-spacing:2px; margin-bottom:5px;">GRAND FINALS</div>
                <div id="gf-slot"></div>
                <div style="height:40px; width:1px; background:var(--connector);"></div> </div>

            <div class="side-col right" id="wb-right"></div>
        </div>

        <div class="lb-container">
            <div class="side-col left" id="lb-left"></div>
            
            <div class="center-stack">
                <div style="color:#777; font-size:0.6rem; letter-spacing:1px;">L-FINALS</div>
                <div id="lb-final-slot"></div>
            </div>

            <div class="side-col right" id="lb-right"></div>
        </div>

    </div>
</div>

<div id="score-overlay">
    <div class="score-card">
        <div class="sc-row">
            <span id="modP1" style="font-weight:bold; max-width:100px; overflow:hidden;">P1</span>
            <button class="btn-adj" onclick="mod(-1, 1)">-</button>
            <input id="inpS1" class="sc-inp" readonly value="0">
            <button class="btn-adj" onclick="mod(1, 1)">+</button>
        </div>
        <div class="sc-row">
            <span id="modP2" style="font-weight:bold; max-width:100px; overflow:hidden;">P2</span>
            <button class="btn-adj" onclick="mod(-1, 2)">-</button>
            <input id="inpS2" class="sc-inp" readonly value="0">
            <button class="btn-adj" onclick="mod(1, 2)">+</button>
        </div>
        <div style="display:flex; gap:10px; margin-top:15px;">
            <button class="btn" style="flex:1" onclick="closeScore()">Cancel</button>
            <button class="btn btn-p" style="flex:1" onclick="saveScore()">Confirm</button>
        </div>
    </div>
</div>

<script>
    let data = { matches: [], active: false };
    let curId = null;

    // --- LOGIC: BRACKET GENERATION ---
    function generate() {
        const txt = document.getElementById('pInput').value.trim();
        let names = txt.split('\n').map(x=>x.trim()).filter(x=>x);
        if(names.length < 4) return alert("Need 4+ players");

        // Shuffle & Fill to 16
        names.sort(() => Math.random() - 0.5);
        const seeds = [];
        for(let i=0; i<16; i++) seeds.push(names[i] || "BYE");

        const matches = [];

        // --- WINNERS BRACKET ---
        // WB R1 (8 matches) - Id: w1_0 to w1_7
        let w1 = [];
        for(let i=0; i<8; i++) {
            const id = `w1_${i}`;
            const side = i<4 ? 'left' : 'right';
            matches.push({ id, type:'wb', r:1, side, p1: seeds[i*2], p2: seeds[i*2+1], s1:0, s2:0, win:null });
            w1.push(id);
        }

        // WB R2 (4 matches)
        let w2 = [];
        for(let i=0; i<4; i++) {
            const id = `w2_${i}`;
            const side = i<2 ? 'left' : 'right';
            matches.push({ id, type:'wb', r:2, side, p1:null, p2:null, s1:0, s2:0, win:null });
            w2.push(id);
            link(matches, w1[i*2], id, 1);
            link(matches, w1[i*2+1], id, 2);
        }

        // WB R3 (2 matches - Semis)
        let w3 = [];
        for(let i=0; i<2; i++) {
            const id = `w3_${i}`;
            const side = i===0 ? 'left' : 'right';
            matches.push({ id, type:'wb', r:3, side, p1:null, p2:null, s1:0, s2:0, win:null });
            w3.push(id);
            link(matches, w2[i*2], id, 1);
            link(matches, w2[i*2+1], id, 2);
        }

        // WB R4 (Winners Final is implicit, we skip straight to GF for display simplicity, 
        // usually WB winner waits in GF. But for 16p, WB R3 winners are the "WB Finals" equivalent 
        // if we consider standard 8-man, but this is 16-man.
        // Wait, 16 -> 8 -> 4 -> 2. So WB R4 is WB Finals.
        const idWF = 'w4_0'; // WB Finals
        matches.push({ id: idWF, type:'wb', r:4, side:'center', p1:null, p2:null, s1:0, s2:0, win:null });
        link(matches, w3[0], idWF, 1);
        link(matches, w3[1], idWF, 2);


        // --- LOSERS BRACKET (The tricky part) ---
        // LB has 6 rounds before LB Final for 16 participants.
        
        // LB R1 (4 Matches): Feeds from WB R1 Losers
        let l1 = [];
        for(let i=0; i<4; i++) {
            const id = `l1_${i}`;
            const side = i<2 ? 'left' : 'right';
            matches.push({ id, type:'lb', r:1, side, p1:null, p2:null, s1:0, s2:0, win:null });
            l1.push(id);
            // Cross Pattern: WB losers drop (Simplified: adjacent drop)
            linkLose(matches, w1[i*2], id, 1);
            linkLose(matches, w1[i*2+1], id, 2);
        }

        // LB R2 (4 Matches): Feeds L1 Winners + WB R2 Losers
        let l2 = [];
        for(let i=0; i<4; i++) {
            const id = `l2_${i}`;
            const side = i<2 ? 'left' : 'right';
            matches.push({ id, type:'lb', r:2, side, p1:null, p2:null, s1:0, s2:0, win:null });
            l2.push(id);
            link(matches, l1[i], id, 1);
            linkLose(matches, w2[i], id, 2); // Drop from WB R2
        }

        // LB R3 (2 Matches): Feeds L2 Winners
        let l3 = [];
        for(let i=0; i<2; i++) {
            const id = `l3_${i}`;
            const side = i===0 ? 'left' : 'right';
            matches.push({ id, type:'lb', r:3, side, p1:null, p2:null, s1:0, s2:0, win:null });
            l3.push(id);
            link(matches, l2[i*2], id, 1);
            link(matches, l2[i*2+1], id, 2);
        }

        // LB R4 (2 Matches): Feeds L3 Winners + WB R3 Losers
        let l4 = [];
        for(let i=0; i<2; i++) {
            const id = `l4_${i}`;
            const side = i===0 ? 'left' : 'right';
            matches.push({ id, type:'lb', r:4, side, p1:null, p2:null, s1:0, s2:0, win:null });
            l4.push(id);
            link(matches, l3[i], id, 1);
            linkLose(matches, w3[i], id, 2); // Drop from WB Semis
        }

        // LB R5 (1 Match): LB Semis (Merge Left/Right)
        let l5 = [];
        const idL5 = 'l5_0';
        matches.push({ id: idL5, type:'lb', r:5, side:'center', p1:null, p2:null, s1:0, s2:0, win:null });
        l5.push(idL5);
        link(matches, l4[0], idL5, 1);
        link(matches, l4[1], idL5, 2);

        // LB R6 (1 Match): LB Finals -> Winner of L5 vs Loser of WB Finals
        const idLF = 'l6_0'; // Losers Finals
        matches.push({ id: idLF, type:'lb', r:6, side:'center', p1:null, p2:null, s1:0, s2:0, win:null });
        link(matches, l5[0], idLF, 1);
        linkLose(matches, idWF, idLF, 2); // THE REDEMPTION DROP (Loser of WB Final drops here)

        // --- GRAND FINALS ---
        const idGF = 'gf';
        matches.push({ id: idGF, type:'gf', r:99, side:'center', p1:null, p2:null, s1:0, s2:0, win:null });
        link(matches, idWF, idGF, 1); // Winner of WB Finals
        link(matches, idLF, idGF, 2); // Winner of LB Finals

        data.matches = matches;
        data.active = true;
        
        save();
        render();
        advanceByes();
        document.getElementById('setup-modal').style.display = 'none';
        setTimeout(autoFit, 100);
    }

    // --- LOGIC: LINKING ---
    function link(arr, src, dest, slot) { 
        let m = arr.find(x=>x.id===src); 
        if(m) { m.nextWin = dest; m.winSlot = slot; }
    }
    function linkLose(arr, src, dest, slot) { 
        let m = arr.find(x=>x.id===src); 
        if(m) { m.nextLose = dest; m.loseSlot = slot; }
    }

    // --- RENDER ---
    function render() {
        if(!data.active) return;
        
        // Clear Areas
        const areas = {
            'wb-left': document.getElementById('wb-left'),
            'wb-right': document.getElementById('wb-right'),
            'lb-left': document.getElementById('lb-left'),
            'lb-right': document.getElementById('lb-right')
        };
        Object.values(areas).forEach(e => e.innerHTML = '');
        
        // Render Columns
        // WB Left: R1, R2, R3
        areas['wb-left'].appendChild(buildRoundGroup('wb', 1, 'left'));
        areas['wb-left'].appendChild(buildRoundGroup('wb', 2, 'left'));
        areas['wb-left'].appendChild(buildRoundGroup('wb', 3, 'left'));

        // WB Right: R3, R2, R1 (Reverse order handled by CSS flex-direction)
        areas['wb-right'].appendChild(buildRoundGroup('wb', 3, 'right'));
        areas['wb-right'].appendChild(buildRoundGroup('wb', 2, 'right'));
        areas['wb-right'].appendChild(buildRoundGroup('wb', 1, 'right'));

        // LB Left: R1, R2, R3, R4
        areas['lb-left'].appendChild(buildRoundGroup('lb', 1, 'left'));
        areas['lb-left'].appendChild(buildRoundGroup('lb', 2, 'left'));
        areas['lb-left'].appendChild(buildRoundGroup('lb', 3, 'left'));
        areas['lb-left'].appendChild(buildRoundGroup('lb', 4, 'left'));

        // LB Right
        areas['lb-right'].appendChild(buildRoundGroup('lb', 4, 'right'));
        areas['lb-right'].appendChild(buildRoundGroup('lb', 3, 'right'));
        areas['lb-right'].appendChild(buildRoundGroup('lb', 2, 'right'));
        areas['lb-right'].appendChild(buildRoundGroup('lb', 1, 'right'));

        // Center Specials
        const gf = data.matches.find(m=>m.type==='gf');
        const lf = data.matches.find(m=>m.type==='lb' && m.r===6);
        
        const gfSlot = document.getElementById('gf-slot');
        gfSlot.innerHTML = '';
        if(gf) gfSlot.appendChild(createNode(gf, 'gf-node'));

        const lfSlot = document.getElementById('lb-final-slot');
        lfSlot.innerHTML = '';
        if(lf) lfSlot.appendChild(createNode(lf, 'lb-final-node'));
    }

    function buildRoundGroup(type, round, side) {
        const div = document.createElement('div');
        div.className = 'round-group';
        
        // Calculate dynamic height to align nodes
        // WB R1 has 4 nodes. LB R1 has 2 nodes per side.
        // We set a base height for alignment.
        let h = 300; 
        if(type === 'lb') h = 280; 

        div.style.height = h + 'px';

        const ms = data.matches.filter(m => m.type===type && m.r===round && m.side===side);
        ms.forEach(m => div.appendChild(createNode(m)));
        return div;
    }

    function createNode(m, extraClass='') {
        const el = document.createElement('div');
        el.className = `node ${extraClass}`;
        el.onclick = () => openScore(m.id);
        
        // Classes for colors
        const p1c = m.win === 1 ? 'win' : (m.win === 2 ? 'lose' : '');
        const p2c = m.win === 2 ? 'win' : (m.win === 1 ? 'lose' : '');

        el.innerHTML = `
            <div class="node-id">${m.id.split('_').join('.')}</div>
            <div class="p-row ${p1c}">
                <div class="p-name">${m.p1||'-'}</div>
                <div class="p-sc">${m.s1}</div>
            </div>
            <div class="p-row ${p2c}">
                <div class="p-name">${m.p2||'-'}</div>
                <div class="p-sc">${m.s2}</div>
            </div>
        `;
        return el;
    }

    // --- SCORE HANDLING ---
    function openScore(id) {
        curId = id;
        const m = data.matches.find(x=>x.id===id);
        if(!m.p1 || !m.p2) return;
        
        document.getElementById('modP1').innerText = m.p1;
        document.getElementById('modP2').innerText = m.p2;
        document.getElementById('inpS1').value = m.s1;
        document.getElementById('inpS2').value = m.s2;
        document.getElementById('score-overlay').classList.add('active');
    }
    
    function closeScore() { document.getElementById('score-overlay').classList.remove('active'); curId = null; }
    
    function mod(d, p) {
        const el = document.getElementById(p===1 ? 'inpS1' : 'inpS2');
        el.value = Math.max(0, parseInt(el.value)+d);
    }

    function saveScore() {
        const m = data.matches.find(x=>x.id===curId);
        const s1 = parseInt(document.getElementById('inpS1').value);
        const s2 = parseInt(document.getElementById('inpS2').value);
        
        if(s1 === s2) return alert("Draws not allowed");

        m.s1 = s1; m.s2 = s2;
        m.win = s1 > s2 ? 1 : 2;
        
        const wName = m.win===1 ? m.p1 : m.p2;
        const lName = m.win===1 ? m.p2 : m.p1;

        // Propagate Win
        if(m.nextWin) {
            const dest = data.matches.find(x=>x.id===m.nextWin);
            if(dest) {
                if(m.winSlot === 1) dest.p1 = wName; else dest.p2 = wName;
                dest.win = null; dest.s1=0; dest.s2=0;
            }
        }
        // Propagate Loss
        if(m.nextLose) {
            const dest = data.matches.find(x=>x.id===m.nextLose);
            if(dest) {
                if(m.loseSlot === 1) dest.p1 = lName; else dest.p2 = lName;
                dest.win = null; dest.s1=0; dest.s2=0;
            }
        }

        save(); render(); advanceByes(); closeScore();
    }

    function advanceByes() {
        let dirty = false;
        data.matches.forEach(m => {
            if(!m.win && (m.p1==='BYE' || m.p2==='BYE')) {
                // Auto win against BYE
                m.s1 = m.p2 === 'BYE' ? 1 : 0;
                m.s2 = m.p1 === 'BYE' ? 1 : 0;
                m.win = m.p2 === 'BYE' ? 1 : 2;
                
                const wName = m.win===1 ? m.p1 : m.p2;
                const lName = 'BYE'; // Loser is bye

                if(m.nextWin) {
                    const d = data.matches.find(x=>x.id===m.nextWin);
                    if(d) { if(m.winSlot===1) d.p1=wName; else d.p2=wName; }
                }
                if(m.nextLose) {
                    const d = data.matches.find(x=>x.id===m.nextLose);
                    // Don't forward BYEs to losers bracket, usually allows the other person waiting there to get a bye too,
                    // but for simplicity we forward "BYE" text, and the next loop cleans it up.
                    if(d) { if(m.loseSlot===1) d.p1=lName; else d.p2=lName; }
                }
                dirty = true;
            }
        });
        if(dirty) { save(); render(); }
    }

    // --- UTILS ---
    function autoFit() {
        const root = document.getElementById('bracket-root');
        const stage = document.getElementById('stage');
        
        root.style.transform = 'scale(1)';
        const w = root.scrollWidth + 50;
        const h = root.scrollHeight + 50;
        const scale = Math.min(stage.clientWidth / w, stage.clientHeight / h, 1);
        
        root.style.transform = `scale(${scale})`;
    }

    function save() { localStorage.setItem('unifiedv42', JSON.stringify(data)); }
    function load() { 
        const s = localStorage.getItem('unifiedv42'); 
        if(s) { data = JSON.parse(s); if(data.active){ document.getElementById('setup-modal').style.display='none'; render(); setTimeout(autoFit,100); } }
    }
    function resetAll() { if(confirm("Reset?")) { localStorage.removeItem('unifiedv42'); location.reload(); } }

    window.addEventListener('resize', () => setTimeout(autoFit, 200));
    load();

</script>
</body>
</html>
