<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Unified Bracket v2.2</title>
    <meta name="theme-color" content="#1e1e1e">
    
    <style>
        :root {
            --bg: #121212;
            --card-bg: #1e1e1e;
            --input-bg: #2d2d2d;
            --accent: #4ecdc4; 
            --gold: #f1c40f; 
            --fail: #e74c3c; 
            --text: #e0e0e0;
            --border: #333;
            --win-bg: rgba(78, 205, 196, 0.15);
            --lose-opacity: 0.4;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: var(--bg); 
            color: var(--text); 
            padding: 20px 10px; margin: 0; 
            overscroll-behavior-y: none;
            padding-bottom: 50px;
        }
        .container { 
            width: 100%; max-width: 1200px; margin: 0 auto; 
            display: flex; flex-direction: column; gap: 15px; 
        }
        
        .card { 
            background: var(--card-bg); padding: 15px; 
            border-radius: 12px; border: 1px solid var(--border); 
            display: flex; flex-direction: column; position: relative;
        }
        .section-title { 
            margin: 0; color: #888; font-size: 0.85rem; text-transform: uppercase; 
            border-bottom: 1px solid #333; padding-bottom: 8px; margin-bottom: 8px;
            letter-spacing: 0.05em; font-weight: bold; 
            display: flex; justify-content: space-between; align-items: center;
        }
        button { 
            min-height: 44px; border: none; border-radius: 6px; 
            font-weight: bold; cursor: pointer; font-size: 0.9rem; transition: 0.2s;
        }
        input[type="text"], textarea { 
            background: var(--input-bg); border: 1px solid var(--border); 
            color: #fff; padding: 10px; border-radius: 6px; 
            font-size: 1rem; width: 100%; box-sizing: border-box; 
            font-family: inherit;
        }
        textarea { resize: vertical; min-height: 150px; font-family: monospace; }
        input:focus, textarea:focus { outline: 2px solid var(--accent); border-color: transparent; }

        .btn-action { background: var(--accent); color: #000; width: 100%; margin-top: 10px; }
        .btn-reset-sm { 
            min-height: 26px; font-size: 0.7rem; padding: 0 12px;
            background: #333; color: #ccc; border: 1px solid #444; 
        }
        .btn-reset-sm:hover { background: var(--fail); color: white; border-color: var(--fail); }

        /* --- BRACKET UI FIXED --- */
        .bracket-scroll-area {
            overflow-x: auto; padding-bottom: 20px;
            scrollbar-width: thin; scrollbar-color: #444 #222;
        }
        .bracket-scroll-area::-webkit-scrollbar { height: 8px; }
        .bracket-scroll-area::-webkit-scrollbar-track { background: #222; }
        .bracket-scroll-area::-webkit-scrollbar-thumb { background-color: #444; border-radius: 4px; }

        .bracket-flex { 
            display: flex; 
            gap: 40px; 
            min-width: max-content; 
            padding-right: 20px; 
            /* Crucial: Aligns columns to the top but allows height forcing */
            align-items: flex-start; 
        }
        
        .round-col {
            display: flex; 
            flex-direction: column; 
            justify-content: space-around; /* This handles the vertical centering magic */
            gap: 0; /* Let space-around handle gaps */
            min-width: 220px; 
            position: relative;
            /* Height is set dynamically by JS to ensure alignment */
        }

        .round-title {
            text-align: center; font-size: 0.7rem; color: var(--gold);
            text-transform: uppercase; font-weight: bold; margin-bottom: 10px;
            position: absolute; top: -25px; left:0; right:0;
            white-space: nowrap;
        }

        /* --- MATCH NODE --- */
        .match-node {
            background: #252525; border: 1px solid #333; border-radius: 6px;
            padding: 4px; display: flex; flex-direction: column; gap: 2px;
            position: relative; 
            height: 60px; /* Fixed height makes alignment calculation safer */
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1;
        }
        
        /* Connectors */
        .round-col:not(:last-child) .match-node::after {
            content: ''; position: absolute; right: -41px; top: 50%; width: 40px; height: 1px;
            background: #555; z-index: 0;
        }

        .match-id {
            position: absolute; top: -8px; right: 5px;
            font-size: 0.55rem; color: #888; background: #252525; padding: 0 4px;
            border: 1px solid #333; border-radius: 4px;
        }

        .competitor-row {
            display: flex; align-items: center; gap: 8px;
            padding: 2px 4px; border-radius: 4px; transition: background 0.2s; cursor: pointer;
            height: 24px;
        }
        .competitor-row:hover { background: rgba(255,255,255,0.05); }
        .competitor-row.winner { background: var(--win-bg); border-left: 2px solid var(--accent); }
        .competitor-row.loser { opacity: var(--lose-opacity); text-decoration: line-through; }

        .name-display { flex: 1; font-weight: bold; font-size: 0.8rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .score-display { 
            width: 20px; text-align: center; font-weight: bold; font-size: 0.8rem;
            background: #111; border: 1px solid #333; border-radius: 3px; color: var(--gold);
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(4px);
            z-index: 9999; display: none; align-items: center; justify-content: center;
        }
        .modal-overlay.active { display: flex; }
        .modal-card { width: 90%; max-width: 400px; background: var(--card-bg); border: 1px solid var(--accent); padding: 20px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .score-control-row {
            display: flex; justify-content: space-between; align-items: center;
            background: #252525; padding: 10px; margin-bottom: 10px; border-radius: 8px;
        }
        .score-btn { width: 40px; background: #333; color: #fff; }
        .score-val-big { font-size: 1.5rem; font-weight: bold; width: 50px; text-align: center; background: transparent; border: none; color: white;}
    </style>
</head>
<body>

<div class="container">

    <div class="card" id="card-setup">
        <div class="section-title">
            <span>Tournament Setup</span>
            <button class="btn-reset-sm" onclick="resetTournament()">Reset</button>
        </div>
        <div style="font-size: 0.8rem; color: #888; margin-bottom: 8px;">
            Supports up to 32 players. <br>
            Paste names (one per line). System will randomize seeds if names are not ordered.
        </div>
        <textarea id="playerInput" placeholder="Name 1&#10;Name 2&#10;..."></textarea>
        <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
            <input type="checkbox" id="chkRandomize" checked> <label for="chkRandomize" style="font-size:0.8rem; color:#aaa;">Randomize Seeds</label>
        </div>
        <button class="btn-action" onclick="generateBracket()">GENERATE BRACKET</button>
    </div>

    <div class="card" id="card-wb" style="display:none;">
        <div class="section-title">
            <span>Winners Bracket</span>
            <button class="btn-reset-sm" onclick="resetTournament()">Clear Tourney</button>
        </div>
        <div class="bracket-scroll-area" style="padding-top: 30px;">
            <div class="bracket-flex" id="wb-container"></div>
        </div>
    </div>

    <div class="card" id="card-lb" style="display:none;">
        <div class="section-title">Losers Bracket</div>
        <div class="bracket-scroll-area" style="padding-top: 30px;">
            <div class="bracket-flex" id="lb-container"></div>
        </div>
    </div>
    
    <div class="card" id="card-finals" style="display:none;">
        <div class="section-title">Grand Finals</div>
        <div class="bracket-flex" style="justify-content: center;" id="finals-container"></div>
    </div>

</div>

<div class="modal-overlay" id="scoreModal">
    <div class="modal-card">
        <h3 style="margin-top:0; color:var(--accent); text-align:center;">Report Match</h3>
        <div class="score-control-row">
            <span id="mP1Name" style="font-weight:bold; width:100px; overflow:hidden; text-overflow:ellipsis;">P1</span>
            <button class="score-btn" onclick="adjScore(1, -1)">-</button>
            <input type="number" id="mP1Score" class="score-val-big" readonly value="0">
            <button class="score-btn" onclick="adjScore(1, 1)">+</button>
        </div>
        <div class="score-control-row">
            <span id="mP2Name" style="font-weight:bold; width:100px; overflow:hidden; text-overflow:ellipsis;">P2</span>
            <button class="score-btn" onclick="adjScore(2, -1)">-</button>
            <input type="number" id="mP2Score" class="score-val-big" readonly value="0">
            <button class="score-btn" onclick="adjScore(2, 1)">+</button>
        </div>
        <div style="display:flex; gap:10px; margin-top:20px;">
            <button style="flex:1; background:#333; color:#ccc;" onclick="closeModal()">Cancel</button>
            <button style="flex:1; background:var(--accent); color:#000;" onclick="confirmMatch()">Confirm Winner</button>
        </div>
    </div>
</div>

<script>
    let tournamentData = { active: false, matches: [], size: 0 };
    let currentMatchId = null;

    function init() {
        const saved = localStorage.getItem('unifiedBracketDataV2');
        if (saved) {
            tournamentData = JSON.parse(saved);
            if (tournamentData.active) {
                document.getElementById('card-setup').style.display = 'none';
                renderBrackets();
            }
        }
    }

    function resetTournament() {
        if(!confirm("Erase all tournament data and start over?")) return;
        tournamentData = { active: false, matches: [], size: 0 };
        localStorage.removeItem('unifiedBracketDataV2');
        location.reload();
    }

    function nextPowerOf2(n) {
        if (n <= 2) return 2;
        return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // --- GENERATION ALGORITHM ---
    function generateBracket() {
        const raw = document.getElementById('playerInput').value.trim();
        let names = raw.split('\n').map(x => x.trim()).filter(x => x !== "");
        
        if (names.length < 3) { alert("Please enter at least 3 players."); return; }
        if (names.length > 32) { alert("Max limit is 32 players."); return; }

        if(document.getElementById('chkRandomize').checked) names = shuffle(names);

        const size = nextPowerOf2(names.length);
        let seeds = [];
        
        for(let i=0; i<size; i++) {
            if (i < names.length) seeds.push(names[i]);
            else seeds.push("BYE");
        }

        let matches = [];
        const wbRounds = Math.log2(size);
        
        // --- WINNERS BRACKET ---
        let wbLayer = []; 

        let currentRoundMatches = [];
        for(let i=0; i < size/2; i++) {
            const mid = `wb1_${i+1}`;
            const p1 = seeds[i];
            const p2 = seeds[size - 1 - i];
            matches.push(createMatch(mid, `WB R1`, 'wb', p1, p2, null, null, 1));
            currentRoundMatches.push(mid);
        }
        wbLayer.push(currentRoundMatches);

        for(let r=2; r <= wbRounds; r++) {
            let nextRoundMatches = [];
            const matchCount = size / Math.pow(2, r);
            const prevLayer = wbLayer[r-2];

            for(let i=0; i < matchCount; i++) {
                const mid = `wb${r}_${i+1}`;
                const name = r === wbRounds ? "WB Finals" : (r === wbRounds -1 ? "WB Semis" : `WB R${r}`);
                matches.push(createMatch(mid, name, 'wb', null, null, null, null, 1));
                nextRoundMatches.push(mid);

                const src1 = prevLayer[2*i];
                const src2 = prevLayer[2*i + 1];
                linkNext(matches, src1, mid, 1);
                linkNext(matches, src2, mid, 2);
            }
            wbLayer.push(nextRoundMatches);
        }

        // --- LOSERS BRACKET ---
        const lbTotalRounds = (wbRounds - 1) * 2;
        let lbLayer = []; 

        let lbR1Matches = [];
        for(let i=0; i < (size/4); i++) {
            const mid = `lb1_${i+1}`;
            matches.push(createMatch(mid, `LB R1`, 'lb', null, null, null, null, 1));
            lbR1Matches.push(mid);

            const wbSrc1 = wbLayer[0][2*i]; 
            const wbSrc2 = wbLayer[0][2*i+1];
            linkLose(matches, wbSrc1, mid, 1);
            linkLose(matches, wbSrc2, mid, 2);
        }
        lbLayer.push(lbR1Matches);

        for(let r=2; r <= lbTotalRounds; r++) {
            const isDropRound = (r % 2 === 0); 
            const prevLayer = lbLayer[r-2];
            let currentRoundIds = [];
            
            let count = isDropRound ? prevLayer.length : prevLayer.length / 2;
            
            for(let i=0; i < count; i++) {
                const mid = `lb${r}_${i+1}`;
                let rName = `LB R${r}`;
                if (r === lbTotalRounds) rName = "LB Finals";
                if (r === lbTotalRounds - 1) rName = "LB Semis";

                matches.push(createMatch(mid, rName, 'lb', null, null, null, null, 1));
                currentRoundIds.push(mid);

                if (isDropRound) {
                    linkNext(matches, prevLayer[i], mid, 1);
                    const wbRoundIdx = (r / 2); 
                    const wbSourceId = wbLayer[wbRoundIdx][i]; 
                    linkLose(matches, wbSourceId, mid, 2);
                } else {
                    const src1 = prevLayer[2*i];
                    const src2 = prevLayer[2*i+1];
                    linkNext(matches, src1, mid, 1);
                    linkNext(matches, src2, mid, 2);
                }
            }
            lbLayer.push(currentRoundIds);
        }

        // --- GRAND FINALS ---
        const midGF = `gf_1`;
        matches.push(createMatch(midGF, `Grand Finals`, 'gf', null, null, null, null, 0));
        
        const wbFinalId = wbLayer[wbLayer.length-1][0];
        const lbFinalId = lbLayer[lbLayer.length-1][0];
        linkNext(matches, wbFinalId, midGF, 1);
        linkNext(matches, lbFinalId, midGF, 2);

        tournamentData.matches = matches;
        tournamentData.size = size;
        tournamentData.active = true;
        save();
        
        document.getElementById('card-setup').style.display = 'none';
        renderBrackets();
        autoAdvanceByes();
    }

    function createMatch(id, name, type, p1, p2, nextWin, nextLose, nextSlot) {
        return { id, name, type, p1, p2, s1:0, s2:0, winner:null, nextWin, nextLose, nextWinSlot:nextSlot, nextLoseSlot:0 };
    }
    function linkNext(arr, srcId, destId, slot) {
        const m = arr.find(x => x.id === srcId);
        if(m) { m.nextWin = destId; m.nextWinSlot = slot; }
    }
    function linkLose(arr, srcId, destId, slot) {
        const m = arr.find(x => x.id === srcId);
        if(m) { m.nextLose = destId; m.nextLoseSlot = slot; }
    }

    // --- RENDER LOGIC UPDATED ---
    function renderBrackets() {
        document.getElementById('card-wb').style.display = 'flex';
        document.getElementById('card-lb').style.display = 'flex';
        document.getElementById('card-finals').style.display = 'flex';

        const allWb = tournamentData.matches.filter(m => m.type === 'wb');
        const wbRoundNames = [...new Set(allWb.map(m => m.name))];
        const allLb = tournamentData.matches.filter(m => m.type === 'lb');
        const lbRoundNames = [...new Set(allLb.map(m => m.name))];

        // CALCULATE HEIGHT FOR WINNERS BRACKET
        // Standard height = (Matches in R1 * MatchHeight) + (Matches in R1 * Spacing)
        const wbR1Count = tournamentData.matches.filter(m => m.name === 'WB R1').length;
        // 60px is card height, 20px is minimum spacing factor
        const wbTotalHeight = Math.max(400, (wbR1Count * 90)); 

        renderSection('wb-container', wbRoundNames, 'wb', wbTotalHeight);
        
        // CALCULATE HEIGHT FOR LOSERS BRACKET
        const lbR1Count = tournamentData.matches.filter(m => m.name === 'LB R1').length;
        const lbTotalHeight = Math.max(400, (lbR1Count * 90)); 

        renderSection('lb-container', lbRoundNames, 'lb', lbTotalHeight);
        
        const finalsContainer = document.getElementById('finals-container');
        finalsContainer.innerHTML = '';
        const gfMatch = tournamentData.matches.find(m => m.type === 'gf');
        if(gfMatch) finalsContainer.appendChild(createMatchNode(gfMatch));
    }

    function renderSection(containerId, roundNames, type, forcedHeight) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        
        roundNames.forEach(rName => {
            const col = document.createElement('div');
            col.className = 'round-col';
            // FORCE HEIGHT TO ENSURE ALIGNMENT
            col.style.height = forcedHeight + 'px';

            const title = document.createElement('div');
            title.className = 'round-title';
            title.innerText = rName;
            col.appendChild(title);

            const matches = tournamentData.matches.filter(m => m.name === rName && m.type === type);
            matches.forEach(m => col.appendChild(createMatchNode(m)));
            container.appendChild(col);
        });
    }

    function createMatchNode(m) {
        const div = document.createElement('div');
        div.className = 'match-node';
        div.onclick = () => openScoreModal(m.id);
        const p1Class = m.winner === 1 ? 'winner' : (m.winner === 2 ? 'loser' : '');
        const p2Class = m.winner === 2 ? 'winner' : (m.winner === 1 ? 'loser' : '');
        div.innerHTML = `
            <div class="match-id">${m.id.split('_')[1]}</div>
            <div class="competitor-row ${p1Class}">
                <div class="name-display" style="color:${m.p1 ? '#fff' : '#555'}">${m.p1 || 'TBD'}</div>
                <div class="score-display">${m.s1}</div>
            </div>
            <div class="competitor-row ${p2Class}">
                <div class="name-display" style="color:${m.p2 ? '#fff' : '#555'}">${m.p2 || 'TBD'}</div>
                <div class="score-display">${m.s2}</div>
            </div>
        `;
        return div;
    }

    // --- GAMEPLAY ---
    function openScoreModal(mid) {
        const m = tournamentData.matches.find(x => x.id === mid);
        if(!m.p1 || !m.p2) return; 
        currentMatchId = mid;
        document.getElementById('mP1Name').innerText = m.p1;
        document.getElementById('mP2Name').innerText = m.p2;
        document.getElementById('mP1Score').value = m.s1;
        document.getElementById('mP2Score').value = m.s2;
        document.getElementById('scoreModal').classList.add('active');
    }

    function closeModal() {
        document.getElementById('scoreModal').classList.remove('active');
        currentMatchId = null;
    }

    function adjScore(p, delta) {
        const el = document.getElementById(p === 1 ? 'mP1Score' : 'mP2Score');
        let val = parseInt(el.value) || 0;
        val = Math.max(0, val + delta);
        el.value = val;
    }

    function confirmMatch() {
        if (!currentMatchId) return;
        const m = tournamentData.matches.find(x => x.id === currentMatchId);
        const s1 = parseInt(document.getElementById('mP1Score').value);
        const s2 = parseInt(document.getElementById('mP2Score').value);
        if (s1 === s2) { alert("Draws not allowed"); return; }

        m.s1 = s1; m.s2 = s2;
        m.winner = s1 > s2 ? 1 : 2;
        
        const winnerName = m.winner === 1 ? m.p1 : m.p2;
        const loserName = m.winner === 1 ? m.p2 : m.p1;

        if (m.nextWin) {
            const nextM = tournamentData.matches.find(x => x.id === m.nextWin);
            if (nextM) {
                if (m.nextWinSlot === 1) nextM.p1 = winnerName;
                else nextM.p2 = winnerName;
                if(nextM.p1 && nextM.p2 && nextM.winner) { nextM.winner = null; nextM.s1=0; nextM.s2=0; }
            }
        }
        if (m.nextLose) {
            const nextL = tournamentData.matches.find(x => x.id === m.nextLose);
            if (nextL) {
                if (m.nextLoseSlot === 1) nextL.p1 = loserName;
                else nextL.p2 = loserName;
                if(nextL.p1 && nextL.p2 && nextL.winner) { nextL.winner = null; nextL.s1=0; nextL.s2=0; }
            }
        }

        save(); renderBrackets(); closeModal(); autoAdvanceByes();
    }

    function autoAdvanceByes() {
        let changed = false;
        tournamentData.matches.forEach(m => {
            if (!m.winner && m.p1 && m.p2) {
                if (m.p1 === 'BYE' || m.p2 === 'BYE') {
                    m.s1 = m.p2 === 'BYE' ? 1 : 0;
                    m.s2 = m.p1 === 'BYE' ? 1 : 0;
                    m.winner = m.p2 === 'BYE' ? 1 : 2;
                    
                    const winnerName = m.winner === 1 ? m.p1 : m.p2;
                    const loserName = "BYE";

                    if (m.nextWin) {
                        const nextM = tournamentData.matches.find(x => x.id === m.nextWin);
                        if (nextM) {
                            if (m.nextWinSlot === 1) nextM.p1 = winnerName; else nextM.p2 = winnerName;
                        }
                    }
                    if (m.nextLose) {
                        const nextL = tournamentData.matches.find(x => x.id === m.nextLose);
                        if (nextL) {
                            if (m.nextLoseSlot === 1) nextL.p1 = loserName; else nextL.p2 = loserName;
                        }
                    }
                    changed = true;
                }
            }
        });
        if(changed) { save(); renderBrackets(); autoAdvanceByes(); }
    }

    function save() { localStorage.setItem('unifiedBracketDataV2', JSON.stringify(tournamentData)); }

    init();
</script>
</body>
</html>
