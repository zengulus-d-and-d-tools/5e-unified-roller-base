<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Unified Bracket v4.0 (Split Layout)</title>
    <meta name="theme-color" content="#121212">
    
    <style>
        :root {
            --bg: #121212;
            --card-bg: #1e1e1e;
            --node-bg: #262626;
            --node-hover: #333;
            --accent: #4ecdc4;
            --accent-dim: rgba(78, 205, 196, 0.1);
            --gold: #f1c40f;
            --fail: #e74c3c;
            --border: #444;
            --text-main: #eee;
            --text-muted: #888;
            --win-bg: rgba(78, 205, 196, 0.15);
            --connector: #555;
        }

        body { 
            font-family: 'Segoe UI', Roboto, sans-serif; 
            background: var(--bg); 
            color: var(--text-main); 
            margin: 0; padding: 20px;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container { 
            width: 98%; max-width: 1800px; margin: 0 auto; 
            display: flex; flex-direction: column; gap: 30px; 
        }

        /* --- CARDS --- */
        .card { 
            background: var(--card-bg); 
            padding: 20px; 
            border-radius: 12px; 
            border: 1px solid #333; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .section-header { 
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px;
        }
        .section-title { font-weight: 700; color: var(--accent); letter-spacing: 1px; text-transform: uppercase; }

        /* --- BUTTONS & INPUTS --- */
        button { cursor: pointer; border: none; border-radius: 4px; font-weight: 600; transition: 0.2s; }
        .btn-action { background: var(--accent); color: #000; width: 100%; height: 40px; margin-top: 10px; }
        .btn-ghost { background: transparent; border: 1px solid #555; color: #aaa; padding: 5px 15px; font-size: 0.8rem; }
        .btn-ghost:hover { border-color: var(--fail); color: var(--fail); }

        textarea { 
            width: 100%; background: #151515; border: 1px solid #333; color: #fff; 
            padding: 10px; border-radius: 6px; min-height: 100px; box-sizing: border-box;
            font-family: monospace; margin-bottom: 10px;
        }

        /* --- SPLIT LAYOUT SYSTEM --- */
        .split-bracket-wrapper {
            display: flex;
            justify-content: center;
            align-items: stretch;
            gap: 40px;
            padding: 20px 0;
            overflow-x: auto;
        }

        /* The Left and Right Trees */
        .bracket-tree {
            display: flex;
            gap: 60px;
        }
        .bracket-tree.right-tree {
            flex-direction: row-reverse; /* Mirrors the columns for the right side */
        }

        .round-col {
            display: flex; 
            flex-direction: column; 
            min-width: 220px; 
            position: relative;
        }

        /* FIX FOR HEADER OVERLAP: Flex layout inside column */
        .col-header {
            text-align: center; color: var(--gold); font-size: 0.75rem; 
            font-weight: bold; text-transform: uppercase; margin-bottom: 15px;
            height: 20px; /* Fixed height for header */
        }
        .col-matches {
            flex: 1;
            display: flex; flex-direction: column; justify-content: space-around;
            gap: 20px; /* Fallback gap */
        }

        /* --- MATCH NODES --- */
        .match-node {
            background: var(--node-bg); border: 1px solid #333; border-radius: 6px;
            padding: 8px; height: 64px; display: flex; flex-direction: column; justify-content: center;
            position: relative; cursor: pointer; transition: transform 0.2s, background 0.2s;
            z-index: 2;
        }
        .match-node:hover { background: var(--node-hover); transform: scale(1.02); border-color: #555; }

        .match-id {
            position: absolute; top: -8px; right: 5px; font-size: 0.6rem; 
            color: #666; background: var(--node-bg); padding: 0 4px; border: 1px solid #333;
        }

        /* CONNECTORS - LEFT SIDE (Standard) */
        .left-tree .round-col:not(:last-child) .match-node::after {
            content: ''; position: absolute; right: -61px; top: 50%; width: 60px; height: 2px; background: var(--connector); z-index: -1;
        }
        .left-tree .round-col:not(:last-child) .match-node::before {
            content: ''; position: absolute; right: -4px; top: 50%; transform: translateY(-50%); 
            width: 6px; height: 6px; background: #777; border-radius: 50%;
        }

        /* CONNECTORS - RIGHT SIDE (Mirrored) */
        /* Note: Since we use flex-direction: row-reverse, "last-child" is physically the one closest to center */
        .right-tree .round-col:not(:last-child) .match-node::after {
            content: ''; position: absolute; left: -61px; top: 50%; width: 60px; height: 2px; background: var(--connector); z-index: -1;
        }
        .right-tree .round-col:not(:last-child) .match-node::before {
            content: ''; position: absolute; left: -4px; top: 50%; transform: translateY(-50%); 
            width: 6px; height: 6px; background: #777; border-radius: 50%;
        }

        /* CENTER CONVERGENCE (WB FINALS) */
        .wb-center-col {
            display: flex; flex-direction: column; justify-content: center;
            min-width: 240px; position: relative;
        }
        .wb-center-col .match-node { border-color: var(--accent); box-shadow: 0 0 15px var(--accent-dim); }
        /* Connectors for center node receiving from both sides */
        .wb-center-col .match-node::before {
            content: ''; position: absolute; left: -30px; top: 50%; width: 30px; height: 2px; background: var(--connector);
        }
        .wb-center-col .match-node::after {
            content: ''; position: absolute; right: -30px; top: 50%; width: 30px; height: 2px; background: var(--connector);
        }

        /* COMPETITOR ROWS */
        .comp-row { display: flex; align-items: center; gap: 8px; padding: 2px 0; font-size: 0.9rem; }
        .comp-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #ccc; }
        .comp-score { 
            width: 22px; text-align: center; background: #111; color: var(--gold); 
            border-radius: 3px; font-weight: bold; font-size: 0.85rem; 
        }
        .comp-row.winner .comp-name { color: var(--accent); font-weight: bold; }
        .comp-row.winner .comp-score { background: var(--accent); color: #000; }
        .comp-row.loser { opacity: 0.4; text-decoration: line-through; }

        /* MODAL */
        .modal-bg {
            position: fixed; top:0; left:0; width:100%; height:100%; 
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            display: none; align-items: center; justify-content: center; z-index: 1000;
        }
        .modal-bg.active { display: flex; }
        .modal-box { 
            background: #222; border: 1px solid var(--accent); padding: 25px; 
            border-radius: 12px; width: 90%; max-width: 400px; 
        }
        .score-ctrl { display: flex; justify-content: space-between; align-items: center; background: #151515; padding: 10px; margin-bottom: 10px; border-radius: 8px; }
        .btn-score { width: 35px; height: 35px; background: #333; color: #fff; font-size: 1.2rem; }
        .score-display-big { font-size: 1.8rem; font-weight: bold; color: var(--gold); width: 50px; text-align: center; background: transparent; border: none; }

        /* LOSERS BRACKET SCROLL */
        .lb-scroll-wrapper {
            overflow-x: auto; padding-bottom: 20px;
        }
        .lb-flex { display: flex; gap: 50px; min-width: max-content; }
        
        .toggle-switch { display: flex; align-items: center; gap: 10px; margin-top: 10px; cursor: pointer; }
        .toggle-box { width: 20px; height: 20px; border: 1px solid #555; background: #111; display: grid; place-items: center; }
        .toggle-box.checked { background: var(--accent); border-color: var(--accent); }
    </style>
</head>
<body>

<div class="container">

    <div class="card" id="card-setup">
        <div class="section-header">
            <div class="section-title">Tournament Setup</div>
            <button class="btn-ghost" onclick="resetData()">Reset</button>
        </div>
        <textarea id="playerList" placeholder="Enter names (one per line)..."></textarea>
        <div class="toggle-switch" onclick="toggleRandom()">
            <div class="toggle-box checked" id="chkRandomBox">✓</div>
            <span style="color:#aaa; font-size:0.9rem;">Randomize Seeds</span>
        </div>
        <button class="btn-action" onclick="generateBracket()">Create Bracket</button>
    </div>

    <div class="card" id="card-wb" style="display:none;">
        <div class="section-header">
            <div class="section-title">Winners Bracket</div>
            <button class="btn-ghost" onclick="resetData()">Clear Tourney</button>
        </div>
        
        <div class="split-bracket-wrapper">
            <div class="bracket-tree left-tree" id="wb-left-tree"></div>
            
            <div class="wb-center-col" id="wb-center-node"></div>
            
            <div class="bracket-tree right-tree" id="wb-right-tree"></div>
        </div>
    </div>

    <div class="card" id="card-gf" style="display:none; align-items: center;">
        <div class="section-title" style="margin-bottom: 20px; color: var(--gold);">Grand Finals</div>
        <div id="gf-container"></div>
    </div>

    <div class="card" id="card-lb" style="display:none;">
        <div class="section-header">
            <div class="section-title" style="color:#777;">Losers Bracket</div>
        </div>
        <div class="lb-scroll-wrapper">
            <div class="lb-flex" id="lb-container"></div>
        </div>
    </div>

</div>

<div class="modal-bg" id="scoreModal">
    <div class="modal-box">
        <h3 style="color:var(--accent); text-align:center; margin-top:0;">Match Result</h3>
        <div class="score-ctrl">
            <span id="mP1" style="font-weight:bold; overflow:hidden; text-overflow:ellipsis; width:120px;">P1</span>
            <button class="btn-score" onclick="modScore(1, -1)">-</button>
            <input id="sP1" class="score-display-big" readonly value="0">
            <button class="btn-score" onclick="modScore(1, 1)">+</button>
        </div>
        <div class="score-ctrl">
            <span id="mP2" style="font-weight:bold; overflow:hidden; text-overflow:ellipsis; width:120px;">P2</span>
            <button class="btn-score" onclick="modScore(2, -1)">-</button>
            <input id="sP2" class="score-display-big" readonly value="0">
            <button class="btn-score" onclick="modScore(2, 1)">+</button>
        </div>
        <div style="display:flex; gap:10px; margin-top:20px;">
            <button class="btn-ghost" style="flex:1;" onclick="closeModal()">Cancel</button>
            <button class="btn-action" style="flex:1; margin:0;" onclick="saveMatch()">Confirm</button>
        </div>
    </div>
</div>

<script>
    let data = { active: false, matches: [], size: 0 };
    let curMatch = null;
    let isRandom = true;

    function init() {
        const s = localStorage.getItem('unifiedv4');
        if(s) {
            data = JSON.parse(s);
            if(data.active) {
                document.getElementById('card-setup').style.display = 'none';
                render();
            }
        }
    }

    function resetData() {
        if(confirm("Clear current tournament?")) {
            localStorage.removeItem('unifiedv4');
            location.reload();
        }
    }

    function toggleRandom() {
        isRandom = !isRandom;
        document.getElementById('chkRandomBox').innerHTML = isRandom ? '✓' : '';
        document.getElementById('chkRandomBox').classList.toggle('checked');
    }

    // --- GENERATOR ---
    function generateBracket() {
        const txt = document.getElementById('playerList').value.trim();
        let names = txt.split('\n').map(n => n.trim()).filter(n => n);
        
        if(names.length < 3) return alert("Need 3+ players");
        if(names.length > 32) return alert("Max 32 players");

        if(isRandom) names = names.sort(() => Math.random() - 0.5);

        // Pad to power of 2
        const size = Math.pow(2, Math.ceil(Math.log2(names.length)));
        let seeds = [];
        for(let i=0; i<size; i++) seeds.push(i < names.length ? names[i] : "BYE");

        let matches = [];
        
        // --- WINNERS BRACKET ---
        // We need to tag matches as 'left' or 'right' side for the split view
        // 16 seeds: 0-3 (Left), 4-7 (Right) are the quarters?
        // Actually, simple logic:
        // Size 16. 8 R1 matches. 0-3 Left, 4-7 Right.
        
        const wbRounds = Math.log2(size);
        let wbLayer = [];

        // WB Round 1
        let r1Ids = [];
        for(let i=0; i<size/2; i++) {
            const id = `wb1_${i}`;
            // Determine Side: First half of matches Left, Second half Right
            const side = (i < (size/4)) ? 'left' : 'right';
            
            matches.push({
                id: id, type: 'wb', round: 1, name: 'Round 1', side: side,
                p1: seeds[i], p2: seeds[size-1-i],
                s1:0, s2:0, winner:null, nextWin: null, nextLose: null, slot: 0
            });
            r1Ids.push(id);
        }
        wbLayer.push(r1Ids);

        // WB Next Rounds
        for(let r=2; r<=wbRounds; r++) {
            let rIds = [];
            const count = size / Math.pow(2, r);
            const prev = wbLayer[r-2];

            for(let i=0; i<count; i++) {
                const id = `wb${r}_${i}`;
                let name = `Round ${r}`;
                if(r === wbRounds) name = "WB Final";
                else if(r === wbRounds-1) name = "WB Semis";
                
                // Side logic: if it's the Final, it's 'center'.
                // Otherwise, inherit from children.
                let side = (i < (count/2)) ? 'left' : 'right';
                if(r === wbRounds) side = 'center';

                matches.push({
                    id: id, type: 'wb', round: r, name: name, side: side,
                    p1: null, p2: null, s1:0, s2:0, winner:null, nextWin:null, nextLose:null
                });
                rIds.push(id);

                // Link Prev
                link(matches, prev[i*2], id, 1);
                link(matches, prev[i*2+1], id, 2);
            }
            wbLayer.push(rIds);
        }

        // --- LOSERS BRACKET (Linear) ---
        // Simplified mapping for visual clarity
        const lbTotalRounds = (wbRounds - 1) * 2;
        let lbLayer = [];

        // LB R1
        let lbR1Ids = [];
        for(let i=0; i<size/4; i++) {
            const id = `lb1_${i}`;
            matches.push({
                id: id, type: 'lb', round: 1, name: 'L-Round 1',
                p1: null, p2: null, s1:0, s2:0, winner:null
            });
            lbR1Ids.push(id);
            
            // Drop losers from WB R1
            linkLose(matches, wbLayer[0][i*2], id, 1);
            linkLose(matches, wbLayer[0][i*2+1], id, 2);
        }
        lbLayer.push(lbR1Ids);

        // LB Rest
        for(let r=2; r<=lbTotalRounds; r++) {
            let rIds = [];
            const isDrop = (r%2 === 0);
            const prev = lbLayer[r-2];
            const count = isDrop ? prev.length : prev.length/2;

            for(let i=0; i<count; i++) {
                const id = `lb${r}_${i}`;
                let name = `L-Round ${r}`;
                if(r === lbTotalRounds) name = "L-Finals";

                matches.push({
                    id: id, type: 'lb', round: r, name: name,
                    p1: null, p2: null, s1:0, s2:0, winner:null
                });
                rIds.push(id);

                if(isDrop) {
                    link(matches, prev[i], id, 1);
                    // Drop from WB
                    // WB Round index = r/2
                    const wbSrc = wbLayer[(r/2)][i];
                    linkLose(matches, wbSrc, id, 2);
                } else {
                    link(matches, prev[i*2], id, 1);
                    link(matches, prev[i*2+1], id, 2);
                }
            }
            lbLayer.push(rIds);
        }

        // --- GRAND FINALS ---
        const gfId = 'gf';
        matches.push({
            id: gfId, type: 'gf', round: 99, name: 'Grand Finals',
            p1: null, p2: null, s1:0, s2:0, winner:null
        });

        // WB Winner -> GF P1
        link(matches, wbLayer[wbLayer.length-1][0], gfId, 1);
        // LB Winner -> GF P2
        link(matches, lbLayer[lbLayer.length-1][0], gfId, 2);

        data.matches = matches;
        data.active = true;
        save();
        render();
        advanceByes();
        
        document.getElementById('card-setup').style.display = 'none';
    }

    function link(arr, srcId, destId, slot) {
        const m = arr.find(x => x.id === srcId);
        if(m) { m.nextWin = destId; m.nextWinSlot = slot; }
    }
    function linkLose(arr, srcId, destId, slot) {
        const m = arr.find(x => x.id === srcId);
        if(m) { m.nextLose = destId; m.nextLoseSlot = slot; }
    }

    // --- RENDERER ---
    function render() {
        document.getElementById('card-wb').style.display = 'block';
        document.getElementById('card-lb').style.display = 'block';
        document.getElementById('card-gf').style.display = 'flex';

        // 1. Separate Winners Bracket into Columns
        const wb = data.matches.filter(m => m.type === 'wb');
        // Group by Round
        const rounds = {};
        wb.forEach(m => {
            if(!rounds[m.round]) rounds[m.round] = [];
            rounds[m.round].push(m);
        });

        // Determine Containers
        const leftTree = document.getElementById('wb-left-tree');
        const rightTree = document.getElementById('wb-right-tree');
        const centerNode = document.getElementById('wb-center-node');
        
        leftTree.innerHTML = '';
        rightTree.innerHTML = '';
        centerNode.innerHTML = '';

        // Determine max matches in a column to calculate fixed height
        // The first round has the most matches.
        const r1Count = wb.filter(m => m.round === 1).length;
        // Height per match (approx 80px + gaps)
        // If R1 has 8 matches (4 left, 4 right), height is based on 4.
        const colHeight = Math.max(400, (r1Count/2) * 110);

        // Iterate Rounds
        Object.keys(rounds).sort((a,b)=>a-b).forEach(rKey => {
            const matches = rounds[rKey];
            
            // Center Node (Finals)
            const centerM = matches.find(m => m.side === 'center');
            if(centerM) {
                centerNode.appendChild(createMatchEl(centerM));
                return;
            }

            // Left Col
            const leftMatches = matches.filter(m => m.side === 'left');
            if(leftMatches.length > 0) {
                const col = createCol(leftMatches, matches[0].name, colHeight);
                leftTree.appendChild(col);
            }

            // Right Col
            const rightMatches = matches.filter(m => m.side === 'right');
            if(rightMatches.length > 0) {
                const col = createCol(rightMatches, matches[0].name, colHeight);
                rightTree.appendChild(col); // Flex-reverse handles order
                // Note: Right tree logic puts Round 1 on far right, Round 2 closer to center.
                // Since flex-direction is row-reverse, appending R1 then R2 works perfectly?
                // No, standard appending order: Left Tree: R1 -> R2 -> Center.
                // Right Tree: R1 -> R2 -> Center.
                // If I append R1 then R2 to Right Tree container, Row Reverse puts R1 on Far Right, R2 on Left of it. Correct.
            }
        });

        // 2. Render Losers
        const lb = data.matches.filter(m => m.type === 'lb');
        const lbContainer = document.getElementById('lb-container');
        lbContainer.innerHTML = '';
        
        // Group LB by Round
        const lbRounds = {};
        lb.forEach(m => {
            if(!lbRounds[m.round]) lbRounds[m.round] = [];
            lbRounds[m.round].push(m);
        });
        
        // LB Height
        const lbR1Count = lb.filter(m => m.round === 1).length;
        const lbHeight = Math.max(300, lbR1Count * 110);

        Object.keys(lbRounds).sort((a,b)=>a-b).forEach(rKey => {
            const col = createCol(lbRounds[rKey], lbRounds[rKey][0].name, lbHeight);
            lbContainer.appendChild(col);
        });

        // 3. Grand Finals
        const gf = data.matches.find(m => m.type === 'gf');
        const gfContainer = document.getElementById('gf-container');
        gfContainer.innerHTML = '';
        if(gf) gfContainer.appendChild(createMatchEl(gf));
    }

    function createCol(matches, title, height) {
        const col = document.createElement('div');
        col.className = 'round-col';
        col.style.height = height + 'px'; // Enforce alignment

        const head = document.createElement('div');
        head.className = 'col-header';
        head.innerText = title;
        col.appendChild(head);

        const track = document.createElement('div');
        track.className = 'col-matches';
        matches.forEach(m => track.appendChild(createMatchEl(m)));
        col.appendChild(track);

        return col;
    }

    function createMatchEl(m) {
        const el = document.createElement('div');
        el.className = 'match-node';
        el.onclick = () => openModal(m.id);

        // ID Label
        const idTag = document.createElement('div');
        idTag.className = 'match-id';
        // Cleanup ID for display (wb1_0 -> 1.1)
        const parts = m.id.split('_');
        idTag.innerText = parts[0].toUpperCase() + (parts[1] ? '.' + (parseInt(parts[1])+1) : '');
        el.appendChild(idTag);

        // P1
        el.innerHTML += `
            <div class="comp-row ${m.winner===1?'winner':(m.winner===2?'loser':'')}">
                <div class="comp-name">${m.p1||'-'}</div>
                <div class="comp-score">${m.s1}</div>
            </div>
            <div class="comp-row ${m.winner===2?'winner':(m.winner===1?'loser':'')}">
                <div class="comp-name">${m.p2||'-'}</div>
                <div class="comp-score">${m.s2}</div>
            </div>
        `;
        return el;
    }

    // --- SCORING ---
    function openModal(id) {
        const m = data.matches.find(x => x.id === id);
        if(!m.p1 || !m.p2) return;
        curMatch = m;
        document.getElementById('mP1').innerText = m.p1;
        document.getElementById('mP2').innerText = m.p2;
        document.getElementById('sP1').value = m.s1;
        document.getElementById('sP2').value = m.s2;
        document.getElementById('scoreModal').classList.add('active');
    }

    function closeModal() {
        document.getElementById('scoreModal').classList.remove('active');
        curMatch = null;
    }

    function modScore(p, d) {
        const id = p===1 ? 'sP1' : 'sP2';
        const el = document.getElementById(id);
        el.value = Math.max(0, parseInt(el.value)+d);
    }

    function saveMatch() {
        if(!curMatch) return;
        const s1 = parseInt(document.getElementById('sP1').value);
        const s2 = parseInt(document.getElementById('sP2').value);
        if(s1 === s2) return alert("No draws allowed");

        curMatch.s1 = s1;
        curMatch.s2 = s2;
        curMatch.winner = s1 > s2 ? 1 : 2;

        const wName = curMatch.winner === 1 ? curMatch.p1 : curMatch.p2;
        const lName = curMatch.winner === 1 ? curMatch.p2 : curMatch.p1;

        // Push Winner
        if(curMatch.nextWin) {
            const next = data.matches.find(m => m.id === curMatch.nextWin);
            if(next) {
                if(curMatch.nextWinSlot === 1) next.p1 = wName; else next.p2 = wName;
                // Reset next match if it was already played
                next.winner = null; next.s1 = 0; next.s2 = 0;
            }
        }

        // Push Loser
        if(curMatch.nextLose) {
            const next = data.matches.find(m => m.id === curMatch.nextLose);
            if(next) {
                if(curMatch.nextLoseSlot === 1) next.p1 = lName; else next.p2 = lName;
                next.winner = null; next.s1 = 0; next.s2 = 0;
            }
        }

        save(); render(); closeModal(); advanceByes();
    }

    function advanceByes() {
        let change = false;
        data.matches.forEach(m => {
            if(!m.winner && m.p1 && m.p2) {
                if(m.p1 === 'BYE' || m.p2 === 'BYE') {
                    m.s1 = m.p2 === 'BYE' ? 1 : 0;
                    m.s2 = m.p1 === 'BYE' ? 1 : 0;
                    m.winner = m.p2 === 'BYE' ? 1 : 2;
                    
                    const wName = m.winner === 1 ? m.p1 : m.p2;
                    const lName = "BYE";

                    if(m.nextWin) {
                        const next = data.matches.find(x => x.id === m.nextWin);
                        if(next) {
                            if(m.nextWinSlot === 1) next.p1 = wName; else next.p2 = wName;
                        }
                    }
                    if(m.nextLose) {
                        const next = data.matches.find(x => x.id === m.nextLose);
                        if(next) {
                            if(m.nextLoseSlot === 1) next.p1 = lName; else next.p2 = lName;
                        }
                    }
                    change = true;
                }
            }
        });
        if(change) { save(); render(); advanceByes(); }
    }

    function save() {
        localStorage.setItem('unifiedv4', JSON.stringify(data));
    }

    init();

</script>
</body>
</html>
