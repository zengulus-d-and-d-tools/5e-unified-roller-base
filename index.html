<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Unified 5e Sheet v4.8</title>
    <meta name="theme-color" content="#1e1e1e">
    
    <style>
        :root {
            --bg: #121212;
            --card-bg: #1e1e1e;
            --input-bg: #2d2d2d;
            --accent: #4ecdc4; 
            --accent-atk: #ff6b6b; 
            --accent-feat: #3498db;
            --gold: #f1c40f; 
            --hp-max: #4a1a1a; 
            --hp-curr: #ef4444; 
            --hp-temp: rgba(59, 130, 246, 0.7); 
            --slot: #9b59b6;  
            --text: #e0e0e0;
            --border: #333;
            --crit: #ffd700; 
            --fail: #e74c3c; 
            --res-bar: #27ae60;
            --swap-mode: #e67e22;
            --secret: #9b59b6;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: var(--bg); 
            color: var(--text); 
            padding: 0; margin: 0; 
            padding-top: 85px; 
            padding-bottom: 50px; 
            overscroll-behavior-y: none;
        }
        
        /* --- LAYOUT CONTAINER --- */
        .sheet-container { 
            width: 100%; 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 10px; 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            box-sizing: border-box; 
            position: relative; 
        }
        
        /* --- UTILITY --- */
        .span-2 { grid-column: span 2; }
        .no-border { border: none !important; padding: 0 !important; margin: 0 !important; }
        .full-width { width: 100%; box-sizing: border-box; }
        .mt-2 { margin-top: 8px; }

        /* --- STICKY HEADER --- */
        .roller-bar { 
            background: rgba(30, 30, 30, 0.98);
            backdrop-filter: blur(8px); 
            padding: 8px 15px; 
            border-bottom: 1px solid #444; 
            display: flex; justify-content: space-between; align-items: center; 
            position: fixed; top: 0; left: 0; right: 0; 
            z-index: 1000; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.4); 
            min-height: 70px; 
            box-sizing: border-box;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        @media (min-width: 900px) {
            .roller-bar { padding: 8px calc(50% - 600px + 15px); }
        }

        .roller-bar.insp-active {
            border-bottom: 2px solid var(--gold);
            box-shadow: 0 4px 15px rgba(241, 196, 15, 0.2);
        }
        
        .controls-left { display: flex; align-items: center; gap: 10px; }
        .adv-controls { display: flex; gap: 4px; }
        .adv-btn { 
            background: #333; border: 1px solid #444; color: #888; 
            padding: 0 10px; height: 38px; border-radius: 6px; 
            cursor: pointer; font-weight: bold; font-size: 0.7rem; 
            transition: 0.2s; display: flex; align-items: center;
        }
        .adv-btn.active[data-mode="adv"] { background: #27ae60; color: #fff; border-color: #27ae60; }
        .adv-btn.active[data-mode="dis"] { background: #c0392b; color: #fff; border-color: #c0392b; }
        .adv-btn.active[data-mode="norm"] { background: #2980b9; color: #fff; border-color: #2980b9; }

        .secret-btn {
            background: #333; border: 1px solid #444; color: #888;
            width: 38px; height: 38px; border-radius: 6px;
            cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center;
            transition: 0.2s;
        }
        .secret-btn.active {
            background: var(--secret); color: #fff; border-color: var(--secret);
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.4);
        }

        .misc-wrapper { 
            display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative;
        }
        .misc-wrapper input { 
            width: 60px !important; height: 30px; text-align: center; font-weight: bold; 
            color: var(--gold); border: 1px solid #444; background: #222; 
            border-radius: 6px; font-size: 0.8rem; padding: 0; margin-top: 14px;
        }
        .misc-label { 
            font-size: 0.6rem; color: #aaa; text-transform: uppercase; 
            font-weight: 600; position: absolute; top: 0; left: 0; width: 100%; text-align: center;
        }

        .log-area { 
            display: flex; flex-direction: column; align-items: flex-end; justify-content: center;
            flex: 1; text-align: right; margin-left: 15px; overflow: hidden;
            height: 55px;
        }
        .log-formula { font-family: monospace; font-size: 0.8rem; color: #888; white-space: nowrap; margin-bottom: 2px; }
        .log-result { font-family: sans-serif; font-size: 1.8rem; font-weight: 900; line-height: 1; color: var(--accent); }
        .crit-text { color: var(--crit); text-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
        .fail-text { color: var(--fail); text-shadow: 0 0 10px rgba(231, 76, 60, 0.3); }

        .toggle-switch {
            position: relative; width: 40px; height: 22px; flex-shrink: 0;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333; transition: .4s; border-radius: 22px; border: 1px solid #555;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent); border-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(18px); background-color: black; }

        .ac-row {
            display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
            background: #252525; padding: 8px; border-radius: 8px; border: 1px solid #333;
        }
        .ac-row.inactive { opacity: 0.6; }
        .ac-val-input { width: 50px !important; text-align: center; font-weight: bold; }

        /* --- UI ELEMENTS --- */
        .card { 
            background: var(--card-bg); padding: 15px; border-radius: 12px; border: 1px solid var(--border); 
            display: flex; flex-direction: column;
            position: relative;
            transition: all 0.2s ease;
            padding-left: 45px; 
            height: fit-content;
        }
        .card.card-collapsed {
            padding-bottom: 5px; 
            padding-top: 10px;
            background: #181818;
        }
        .card.card-collapsed .section-title {
            border-bottom: none; 
            margin-bottom: 0;
            padding-bottom: 5px;
        }

        .card.dragging {
            opacity: 0.5; background: #111; border-color: var(--accent); z-index: 999;
        }
        .card.swap-active {
            border: 2px solid var(--swap-mode) !important;
            box-shadow: 0 0 15px rgba(230, 126, 34, 0.3);
        }
        
        .drag-grip {
            position: absolute; top: 0; left: 0; bottom: 0; width: 35px; 
            display: flex; justify-content: center; align-items: center;
            color: #444; font-size: 18px; letter-spacing: 0;
            cursor: grab; touch-action: none; 
            border-radius: 12px 0 0 12px;
            border-right: 1px solid #252525;
            background: rgba(0,0,0,0.1);
        }
        .drag-grip:hover { color: var(--accent); background: rgba(255,255,255,0.02); }
        .drag-grip::after { content: '‚£ø'; }

        .card.swap-active .drag-grip {
            background: rgba(230, 126, 34, 0.2);
            color: var(--swap-mode);
        }

        .section-title { 
            margin: 0; color: #888; font-size: 0.85rem; text-transform: uppercase; 
            border-bottom: 1px solid #333; padding-bottom: 8px; margin-bottom: 8px;
            letter-spacing: 0.05em; font-weight: bold; 
            display: flex; justify-content: space-between; align-items: center;
        }
        
        .accordion-trigger { cursor: pointer; user-select: none; }
        .accordion-trigger::after {
            content: '‚ñº'; font-size: 0.7rem; color: #666; transition: transform 0.3s ease;
        }
        .accordion-trigger.collapsed { border-bottom-color: transparent; margin-bottom: 0; padding-bottom: 0; }
        .accordion-trigger.collapsed::after { transform: rotate(-90deg); }
        
        .accordion-content {
            overflow: hidden; transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin 0.3s ease;
            max-height: 3000px; opacity: 1;
        }
        .accordion-content.collapsed {
            max-height: 0; opacity: 0; margin: 0; pointer-events: none;
        }

        .header-grid { display: grid; grid-template-columns: 1fr 0.5fr 1fr; gap: 12px; }
        .field-group { display: flex; flex-direction: column; }
        label { font-size: 0.7rem; color: #888; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
        
        input[type="text"], input[type="number"], select, textarea { 
            background: var(--input-bg); border: 1px solid var(--border); color: #fff; padding: 10px; 
            border-radius: 6px; font-size: 1rem; width: 100%; box-sizing: border-box; -webkit-appearance: none; 
        }
        textarea { resize: vertical; font-family: inherit; }
        input:focus, textarea:focus { outline: 2px solid var(--accent); border-color: transparent; }

        .char-switcher-row {
            display: flex; gap: 8px; margin-bottom: 12px;
            padding-bottom: 12px; border-bottom: 1px solid #333;
        }
        #charSelect { flex: 1; font-weight: bold; color: var(--accent); }
        .btn-char-control { 
            width: 44px; display: flex; align-items: center; justify-content: center;
            background: #333; border: 1px solid #444; color: #ccc; border-radius: 6px; cursor: pointer;
        }
        .btn-char-add { color: #2ecc71; }
        .btn-char-del { color: #e74c3c; }

        .hp-visual-bar {
            position: relative; width: 100%; height: 24px;
            background-color: var(--hp-max); border-radius: 6px;
            overflow: hidden; margin-bottom: 10px; border: 1px solid #333;
        }
        .hp-fill-curr { background-color: var(--hp-curr); height: 100%; width: 50%; transition: width 0.3s ease; }
        .hp-fill-temp { 
            position: absolute; top: 0; left: 0; height: 100%; width: 0%; 
            background-color: var(--hp-temp); border-right: 2px solid rgba(255,255,255,0.3); transition: width 0.3s ease; 
        }
        .hp-text-overlay { 
            position: absolute; top:0; left:0; width:100%; height:100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.8rem; font-weight: bold; color: #fff; text-shadow: 0 1px 2px #000; pointer-events: none;
        }

        .hp-grid { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; }
        .hp-box input { text-align: center; font-weight: bold; font-size: 1.2rem; }

        .hp-manage-row {
            display: flex; gap: 8px; margin-top: 10px; align-items: center;
            background: #252525; padding: 10px; border-radius: 8px; border: 1px solid #333;
        }
        #hpInteractVal { width: 70px !important; text-align: center; flex-shrink: 0; }
        .btn-heal { background: #27ae60; color: white; flex: 1; font-weight: bold; }
        .btn-dmg { background: #c0392b; color: white; flex: 1; font-weight: bold; }
        
        .btn-hp-quick {
            background: #333; border: 1px solid #444; color: #fff;
            width: 40px; font-weight: bold; font-size: 1.2rem;
            display: flex; align-items: center; justify-content: center;
            border-radius: 6px; cursor: pointer;
        }
        .btn-hp-quick:active { background: #555; }
        
        .hd-row {
            display: flex; align-items: center; gap: 10px;
            background: #252525; padding: 10px; border-radius: 8px; border: 1px solid #333;
            margin-top: 10px;
        }
        /* UPDATED: Wider width for Hit Dice (3 digits) */
        .hd-val { width: 70px !important; text-align: center; font-weight: bold; color: #fff; }
        
        .btn-roll-hd { 
            background: #e67e22; color: #fff; flex: 1; 
            font-weight: bold; font-size: 0.85rem; height: 38px;
            display: flex; align-items: center; justify-content: center; gap: 6px;
        }
        .btn-roll-hd:disabled { background: #555; color: #888; cursor: not-allowed; }

        .death-save-row {
            display: grid; grid-template-columns: auto 1fr 1fr auto; gap: 10px; 
            align-items: center; background: #252525; padding: 8px; border-radius: 6px; margin-top: 10px;
            border: 1px solid #333;
        }
        .ds-group { display: flex; gap: 8px; align-items: center; justify-content: center; }
        .ds-check { 
            appearance: none; -webkit-appearance: none;
            width: 44px; height: 44px; 
            border-radius: 50%; 
            border: 2px solid #555; cursor: pointer; background: #1a1a1a;
            margin: 0; display: grid; place-content: center;
        }
        .ds-check:checked { box-shadow: 0 0 5px currentColor; border-color: transparent; }
        .ds-succ:checked { background: #2ecc71; color: #2ecc71; }
        .ds-fail:checked { background: #e74c3c; color: #e74c3c; }
        .btn-ds-roll { background: #333; color: #fff; font-size: 0.7rem; font-weight: bold; padding: 5px 10px; border-radius: 4px; cursor: pointer; }

        .rest-row { display: flex; gap: 10px; margin-top: 10px; }
        .btn-rest { flex: 1; background: #2c3e50; color: #ccc; padding: 8px; border-radius: 6px; font-weight: bold; font-size: 0.8rem; cursor: pointer; border: 1px solid #444; }
        .btn-rest:hover { background: #34495e; color: #fff; }

        .ac-wrapper {
            background: #252525; padding: 10px; border-radius: 8px; border: 1px solid #333;
            margin-bottom: 10px;
        }
        .ac-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .ac-val-big { font-size: 1.5rem; font-weight: 900; color: var(--accent); line-height: 1; }
        .ac-config-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 6px; border-top: 1px solid #444; padding-top: 6px; }
        .ac-label-small { font-size: 0.65rem; color: #888; text-transform: uppercase; font-weight: bold; }

        .spell-row { 
            display: flex; align-items: center; gap: 10px; margin-bottom: 8px; 
            background: #252525; padding: 8px; border-radius: 8px;
        }
        .spell-lvl { width: 30px; font-weight: bold; color: var(--slot); font-size: 0.9rem; }
        .spell-max { width: 50px !important; text-align: center; padding: 5px; height: 30px; flex-shrink: 0; }
        .spell-bubbles { display: flex; gap: 8px; flex-wrap: wrap; flex: 1; }
        
        .bubble { 
            width: 38px; height: 38px; 
            margin: 3px; 
            border-radius: 50%; border: 2px solid #555; 
            cursor: pointer; background: #1a1a1a;
            position: relative;
        }
        .bubble::after {
            content: ''; position: absolute; 
            top: -3px; left: -3px; right: -3px; bottom: -3px; 
        }
        .bubble.used { background: var(--slot); border-color: var(--slot); box-shadow: 0 0 5px var(--slot); }

        .dice-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 5px; }
        .dice-btn { 
            background: #333; color: #fff; border: 1px solid #444; padding: 10px; 
            border-radius: 6px; font-weight: bold; cursor: pointer;
        }
        .dice-btn:hover { background: var(--accent); color: #000; }
        .custom-roll-row { display: flex; gap: 10px; margin-top: 10px; }
        .btn-roll-custom { background: var(--accent); color: #000; font-weight: bold; border:none; padding: 0 20px; border-radius: 6px; cursor: pointer;}
        
        .grid-6 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .stat-card { background: var(--card-bg); padding: 8px; border-radius: 8px; text-align: center; border: 1px solid var(--border); display: flex; flex-direction: column; }
        .stat-card h3 { margin: 0 0 2px 0; font-size: 0.8rem; color: #aaa; }
        .score-input { width: 100% !important; text-align: center; font-size: 1.1rem; font-weight: bold; margin-bottom: 2px; padding: 4px !important; background: transparent !important; border: none !important; color: #fff !important; }
        .mod-display { font-size: 0.85rem; color: #888; margin-bottom: 4px; }
        .defense-box { background: #252525; padding: 2px; border-radius: 4px; border-top: 2px solid var(--accent); margin-top: 4px; flex-grow: 1; }
        .defense-val { font-size: 1.1rem; font-weight: bold; color: var(--accent); }
        .save-prof { 
            font-size: 0.65rem; font-weight: bold; color: #888; 
            display: flex; justify-content: center; align-items: center; gap: 6px; 
            margin-bottom: 2px; cursor: pointer; white-space: nowrap;
        }
        .read-only-box {
            background: transparent; border: 1px solid transparent; color: #fff; 
            font-weight: bold; padding: 10px; font-size: 1rem;
        }
        .stat-btn-row { display: flex; gap: 5px; margin-top: 6px; width: 100%; }
        .btn-sm-roll { flex: 1; background: #333; color: #ccc; border: 1px solid #444; border-radius: 4px; font-size: 0.7rem; font-weight: bold; padding: 6px 0; cursor: pointer; text-transform: uppercase; }
        .btn-sm-roll:hover { background: #444; color: white; }
        .btn-sm-save { flex: 1; background: #2c3e50; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 0.7rem; font-weight: bold; padding: 6px 0; cursor: pointer; text-transform: uppercase; }
        .btn-sm-save:hover { background: var(--accent); color: #000; }

        .skill-list { display: grid; grid-template-columns: 1fr; gap: 8px; }
        .skill-row { background: var(--card-bg); padding: 8px 12px; border-radius: 8px; display: flex; align-items: center; gap: 12px; border: 1px solid var(--border); }
        .skill-name { flex: 1; font-size: 0.95rem; font-weight: 500; }
        
          /* NEW: Skill Attribute Toggle Button */
        .skill-attr {
            font-size: 0.7rem; 
            font-weight: bold; 
            color: #888;
            border: 1px solid #444; 
            border-radius: 4px; 
            padding: 4px 8px;
            cursor: pointer; 
            margin-right: 10px; 
            min-width: 30px; 
            text-align: center;
            background: #222;
            transition: all 0.2s;
        }
        .skill-attr:hover { 
            color: #fff; 
            border-color: #666; 
            background: #333;
        }
        .skill-attr.overridden { 
            color: #000; 
            background: var(--accent); 
            border-color: var(--accent); 
            box-shadow: 0 0 5px var(--accent);
        }
        /* NEW: Skill Misc Input */
        .skill-misc {
            width: 35px !important;
            height: 30px;
            padding: 0 !important;
            text-align: center;
            font-size: 0.75rem;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            color: var(--gold);
            font-weight: bold;
            text-transform: uppercase;
        }
        .skill-misc:focus {
            border-color: var(--gold);
            outline: none;
        }

        .prof-toggle { 
            font-size: 1.4rem; padding: 10px; 
            cursor: pointer; min-width: 44px; text-align: center; 
        } 
        .prof-toggle.prof { color: var(--accent); }
        .prof-toggle.exp { color: var(--gold); }
        .btn-roll-skill {
            background: #333; border: 1px solid #444; color: #fff;
            width: 40px; height: 40px; border-radius: 6px; font-size: 1.2rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        .btn-roll-skill:active { background: var(--accent); color: #000; }

        .atk-row { 
            display: flex; flex-direction: column; gap: 8px; 
            margin-bottom: 15px; background: #252525; padding: 10px; 
            border-radius: 8px; border: 1px solid #333; 
        }
        .atk-stats-line { display: grid; grid-template-columns: 2fr 1fr; gap: 8px; }
        .atk-name-input { font-weight: bold; color: #fff; }

        .atk-desc { 
            font-size: 0.85rem; font-style: italic; color: #aaa; 
            border: 1px solid #333; background: rgba(0,0,0,0.2); 
            padding: 8px; border-radius: 4px; min-height: 40px;
        }
        .atk-controls { display: grid; grid-template-columns: 1fr 1fr auto; gap: 8px; }
        
        button { 
            min-height: 44px; 
            border: none; border-radius: 6px; font-weight: bold; cursor: pointer; 
            font-size: 0.9rem; 
        }
        .add-btn { background: var(--accent-atk); color: #000; width: 100%; margin-top: 5px; }

        .webhook-row { margin-top: 5px; padding-top: 10px; border-top: 1px solid #333; }
        .discord-active { color: #5865F2; font-weight: bold; }

        .combat-row {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;
            margin-bottom: 10px;
        }
        .resource-list { display: flex; flex-direction: column; gap: 12px; }
        .resource-row {
            display: flex; flex-direction: column; gap: 8px;
            background: #252525; padding: 10px; border-radius: 8px; border: 1px solid #333;
        }
        .res-top { display: flex; width: 100%; gap: 8px; align-items: center; }
        .res-bottom { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        
        .res-name { font-weight: bold; font-size: 0.9rem; color: #fff; flex: 1; }
        
        .res-controls-row { display: flex; align-items: center; gap: 6px; width: 100%; }
        .res-val { width: 60px !important; text-align: center; font-weight: bold; padding: 5px !important; }
        
        .res-viz-bar { 
            width: 100%; height: 22px; background: #1a1a1a; cursor: pointer;
            border-radius: 4px; position: relative; border: 1px solid #444; overflow: hidden; margin-top: 2px;
        }
        .res-bar-fill { height: 100%; background: var(--res-bar); transition: width 0.3s; }
        
        .res-viz-bubbles { display: flex; gap: 6px; flex-wrap: wrap; width: 100%; padding: 4px 0; margin-top: 2px; }
        .res-bubble-item { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #555; cursor: pointer; background: #1a1a1a; }
        .res-bubble-item.filled { background: var(--res-bar); border-color: var(--res-bar); box-shadow: 0 0 5px var(--res-bar); }

        .res-reset-select { 
            background: #333; color: #ccc; border: 1px solid #444; 
            height: 35px; font-size: 0.75rem; padding: 0 5px;
            border-radius: 6px; font-weight: bold;
        }

        .btn-res-mod {
            background: #333; border: 1px solid #444;
            width: 35px; height: 35px; font-size: 1.2rem; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
        }
        .btn-res-minus { color: var(--fail); }
        .btn-res-plus { color: var(--accent); }
        .btn-res-mod:active { background: #444; }
        
        .btn-res-roll {
            background: var(--gold); color: #000; font-weight: bold; font-size: 0.8rem;
            padding: 0 12px; height: 35px; border-radius: 6px;
        }
        .res-style-select { width: auto !important; padding: 2px 5px !important; height: 30px; font-size: 0.7rem; text-transform: uppercase; font-weight: bold;}

        @media (max-width: 600px) {
            .header-grid { grid-template-columns: 1fr; }
            .span-2 { grid-column: span 1; }
            .log-area { max-width: 140px; margin-left: 10px; }
            .log-result { font-size: 1.5rem; }
            .hp-grid { grid-template-columns: 1fr 1fr; } 
        }
    </style>
</head>
<body>

<div class="roller-bar" id="rollerBar">
    <div class="controls-left">
        <div class="adv-controls">
            <button class="adv-btn" onclick="setMode('dis')" data-mode="dis">DIS</button>
            <button class="adv-btn active" onclick="setMode('norm')" data-mode="norm"> - </button>
            <button class="adv-btn" onclick="setMode('adv')" data-mode="adv">ADV</button>
        </div>
        <button id="btnSecret" class="secret-btn" onclick="toggleSecret()" title="Secret Roll (Discord Spoilers)">üëÅÔ∏è</button>

        <div class="misc-wrapper">
            <span class="misc-label">Misc</span>
            <input type="text" id="globalMisc" placeholder="+0 or 1d4">
        </div>
    </div>
    <div id="logArea" class="log-area">
        <div class="log-formula">Ready...</div>
        <div class="log-result">-</div>
    </div>
</div>

<div class="sheet-container">
    
<div class="card" id="card-vitals">
    <div class="drag-grip"></div>
    
    <div class="char-switcher-row">
        <select id="charSelect" onchange="switchCharacter(this.value)"></select>
        <button class="btn-char-control btn-char-add" onclick="createNewCharacter()">+</button>
        <button class="btn-char-control btn-char-del" onclick="deleteCharacter()">üóëÔ∏è</button>
    </div>

    <div class="header-grid">
        <div class="field-group">
            <label>Character Name</label>
            <input type="text" id="charName" placeholder="Name" oninput="save()">
        </div>
        <div class="field-group">
            <label>Level</label>
            <input type="number" id="charLevel" value="1" oninput="updateLevel(this.value)">
        </div>
        <div class="field-group">
            <label>Caster Type</label>
            <select id="casterType" onchange="save()">
                <option value="none">None</option>
                <option value="full">Full Caster</option>
                <option value="half">Half (Pal/Rgr)</option>
                <option value="third">1/3 (AT/EK)</option>
                <option value="pact">Warlock</option>
            </select>
        </div>
    </div>

    <div class="section-title mt-2">Vitals & Health</div>
    
    <div class="hp-visual-bar">
        <div class="hp-fill-curr" id="barCurr"></div>
        <div class="hp-fill-temp" id="barTemp"></div>
        <div class="hp-text-overlay" id="barText"></div>
    </div>

    <div class="hp-grid">
        <div class="field-group hp-box">
            <label>Current</label>
            <input type="number" id="hpCurr" style="color:var(--hp-curr);" placeholder="0" oninput="updateHP()">
        </div>
        <div class="field-group hp-box">
            <label>Max</label>
            <input type="number" id="hpMax" placeholder="0" oninput="updateHP()">
        </div>
        <div class="field-group hp-box">
            <label>Temp</label>
            <input type="number" id="hpTemp" style="color:var(--hp-temp);" placeholder="0" oninput="updateHP()">
        </div>
        <div class="field-group hp-box">
            <label style="color:var(--gold);">Insp</label>
            <div style="display:flex; height:100%;">
                 <input type="number" id="inspirationVal" style="color:var(--gold); border-color: #555; border-right:none; border-radius:6px 0 0 6px; flex:1; min-width:0; text-align:center;" value="0" oninput="save()">
                 <button onclick="useInspiration()" style="width:50px; background:var(--gold); color:#111; border:1px solid var(--gold); border-radius:0 6px 6px 0; font-size:1.4rem; cursor:pointer; padding:0; display:grid; place-items:center; flex-shrink:0;">‚ö°</button>
            </div>
        </div>
    </div>

    <div class="hp-manage-row">
        <button class="btn-dmg" onclick="modifyHP(true)">Dmg</button>
        <button class="btn-hp-quick" onclick="modifyHP(true, 1)">-1</button>
        <input type="number" id="hpInteractVal" placeholder="Amt">
        <button class="btn-hp-quick" onclick="modifyHP(false, 1)">+1</button>
        <button class="btn-heal" onclick="modifyHP(false)">Heal</button>
    </div>

    <div class="death-save-row" id="deathSaveRow" style="display:none;">
        <button class="btn-ds-roll" onclick="rollDeathSave()">Roll DS</button>
        <div class="ds-group">
            <span style="font-size:0.6rem; color:#2ecc71;">SUCC</span>
            <input type="checkbox" class="ds-check ds-succ" id="ds-s1" onchange="save()"><input type="checkbox" class="ds-check ds-succ" id="ds-s2" onchange="save()"><input type="checkbox" class="ds-check ds-succ" id="ds-s3" onchange="save()">
        </div>
        <div class="ds-group">
            <span style="font-size:0.6rem; color:#e74c3c;">FAIL</span>
            <input type="checkbox" class="ds-check ds-fail" id="ds-f1" onchange="save()"><input type="checkbox" class="ds-check ds-fail" id="ds-f2" onchange="save()"><input type="checkbox" class="ds-check ds-fail" id="ds-f3" onchange="save()">
        </div>
    </div>
</div>

<div class="card" id="card-ac">
    <div class="drag-grip"></div>
    <div class="section-title">
        <span>Armor Class</span>
        <span class="ac-val-big" id="acTotalDisplay">10</span>
    </div>
    
    <label style="font-size:0.7rem; display:flex; align-items:center; gap:5px; margin-bottom:10px;">
        <input type="checkbox" id="acCustomToggle" onchange="toggleACMode()"> Use Custom Formula (Monk/Barb)
    </label>

    <div id="acStdControls" class="grid-6" style="margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:10px;">
        <div class="field-group span-2">
            <label>Base AC (Armor)</label>
            <input type="number" id="acBase" value="10" placeholder="10" oninput="updateAC()">
        </div>
        <div class="field-group span-2">
            <label>Dex Cap</label>
            <select id="acDexCap" onchange="updateAC()" style="padding:5px;">
                <option value="100">None (Light)</option>
                <option value="2">Max +2 (Med)</option>
                <option value="0">0 (Heavy)</option>
            </select>
        </div>
        <div class="field-group span-2">
            <label>Dex Mod</label>
            <div class="read-only-box" id="acDexModDisp" style="text-align:center; color:#888;">+0</div>
        </div>
    </div>
    
    <div id="acCustomControls" class="grid-6" style="display:none; margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:10px;">
        <div class="field-group span-2">
            <label>Base (10)</label>
            <div class="read-only-box" style="text-align:center;">10</div>
        </div>
        <div class="field-group span-2">
            <label>Stat 1</label>
            <select id="acStat1" onchange="updateAC()" style="padding:5px;"></select>
        </div>
        <div class="field-group span-2">
            <label>Stat 2 (Opt)</label>
            <select id="acStat2" onchange="updateAC()" style="padding:5px;"></select>
        </div>
    </div>

    <div id="acBonusList"></div>
    <button class="add-btn" style="background:#333; color:#ccc; border:1px solid #444;" onclick="addAcBonus()">+ Add Bonus (Shield, Magic, etc)</button>
</div>

<div class="card" id="card-rest">
    <div class="drag-grip"></div>
    <div class="section-title">Rest & Hit Dice</div>
    <div class="hd-row">
        <label style="margin:0;">Hit Dice:</label>
        <input type="text" id="hdDie" style="width:40px; text-align:center;" placeholder="d8" oninput="save()">
        <input type="number" id="hdCurr" class="hd-val" placeholder="C" oninput="save()">
        <span>/</span>
        <input type="number" id="hdMax" class="hd-val" placeholder="M" oninput="save()">
        <button class="btn-roll-hd" onclick="rollHitDie()">üé≤ Roll HD</button>
    </div>
    <div class="rest-row">
        <button class="btn-rest" onclick="shortRest()">Short Rest</button>
        <button class="btn-rest" onclick="longRest()">Long Rest</button>
    </div>
</div>

    <div class="card" id="card-combat">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-combat" onclick="toggleSection('combat')">
            <span>Combat Stats & Resources</span>
        </div>
        <div class="accordion-content" id="body-combat">
            <div class="combat-row">
                <div class="field-group">
                    <label>Initiative</label>
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="initBonus" placeholder="+0" oninput="save()">
                        <button class="btn-sm-roll" style="width:40px;" onclick="rollInitiative()">üé≤</button>
                    </div>
                </div>
                <div class="field-group">
                    <label>Speed (ft)</label>
                    <input type="text" id="speedVal" placeholder="30" oninput="save()">
                </div>
                <div class="field-group">
                    <label>Spell DC</label>
                    <div class="read-only-box" id="globalDC" style="text-align:center; color:var(--slot);">--</div>
                </div>
            </div>

            <div class="section-title" style="border:none; font-size:0.7rem;">Class Resources / Ammo</div>
            <div id="resourceList" class="resource-list"></div>
            <button class="add-btn" style="background: #2c3e50; color: #fff; margin-top:10px;" onclick="addResource()">+ Add Counter</button>
        </div>
    </div>

    <div class="card" id="card-attr">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-attr" onclick="toggleSection('attr')">
            <span>Attributes</span>
        </div>
        <div class="accordion-content" id="body-attr">
            <div class="grid-6" id="statsGrid"></div>
        </div>
    </div>

    <div class="card" id="card-atk">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-atk" onclick="toggleSection('atk')">
            <span>Attacks</span>
        </div>
        <div class="accordion-content" id="body-atk">
            <div id="attackList"></div>
            <button class="add-btn" onclick="addAttack()">+ Add Weapon / Spell</button>
        </div>
    </div>
    
    <div class="card" id="card-feats">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-feats" onclick="toggleSection('feats')">
            <span>Features & Traits</span>
        </div>
        <div class="accordion-content" id="body-feats">
            <div id="featureList"></div>
            <button class="add-btn" style="background: var(--accent-feat); color: #fff;" onclick="addFeature()">+ Add Feature</button>
        </div>
    </div>

    <div class="card" id="card-spells">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-spells" onclick="toggleSection('spells')">
            <span>Spell Slots</span>
        </div>
        <div class="accordion-content" id="body-spells">
            <div style="margin-bottom:10px; display:flex; justify-content:flex-end;">
                <button onclick="calcSpellSlots()" style="background:#2c3e50; color:#fff; font-size:0.7rem; height:30px; padding:0 10px;">Auto-Calc Slots (From Level)</button>
            </div>
            <div id="spellSlotsList"></div>
        </div>
    </div>

    <div class="card" id="card-skills">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-skills" onclick="toggleSection('skills')">
            <span>Skills</span>
        </div>
        <div class="accordion-content" id="body-skills">
            <div class="skill-list" id="skillGrid"></div>
        </div>
    </div>

    <div class="card" id="card-roller">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-roller" onclick="toggleSection('roller')">
            <span>Arbitrary Roller</span>
        </div>
        <div class="accordion-content" id="body-roller">
            <div class="custom-roll-row" style="margin-bottom:10px;">
                <input type="text" id="customLabel" placeholder="Optional Label (e.g. Healing Potion)">
            </div>
            <div class="dice-grid">
                <button class="dice-btn" onclick="rollDie(4,0,'d4',false,'check')">d4</button>
                <button class="dice-btn" onclick="rollDie(6,0,'d6',false,'check')">d6</button>
                <button class="dice-btn" onclick="rollDie(8,0,'d8',false,'check')">d8</button>
                <button class="dice-btn" onclick="rollDie(10,0,'d10',false,'check')">d10</button>
                <button class="dice-btn" onclick="rollDie(12,0,'d12',false,'check')">d12</button>
                <button class="dice-btn" onclick="rollDie(20,0,'d20',true,'check')">d20</button>
                <button class="dice-btn" onclick="rollDie(100,0,'d100',false,'check')">d100</button>
            </div>
            <div class="custom-roll-row">
                <input type="text" id="customFormula" placeholder="e.g. 4d6r1d1">
                <button class="btn-roll-custom" onclick="rollCustom()">Roll</button>
            </div>
        </div>
    </div>

    <div class="card io-card" id="card-io">
        <div class="drag-grip"></div>
        <div class="section-title accordion-trigger" id="head-io" onclick="toggleSection('io')">
            <span>Backup Data</span>
        </div>
        <div class="accordion-content" id="body-io">
            <div class="field-group">
                <label>Discord Webhook</label>
                <input type="text" id="webhookUrl" placeholder="https://discord.com/api/webhooks/..." oninput="save()">
            </div>
            <label class="discord-toggle" id="discordLabel" style="display:flex; align-items:center; gap:8px; margin:10px 0; color:#aaa; font-size:0.9rem;">
                <input type="checkbox" id="sendToDiscord" onchange="toggleDiscord(this.checked)"> 
                <span>Active (Send to Discord)</span>
            </label>
            <div class="field-group">
                <label>Player Name (For Log)</label>
                <input type="text" id="playerName" placeholder="Your Name" oninput="save()">
            </div>
            
            <textarea id="ioField" rows="2" placeholder="Save string..." style="width:100%; font-family:monospace; color:var(--accent); resize:none; margin-top:10px;"></textarea>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button style="flex:1; background:#333; color:#ccc;" onclick="exportData()">Copy Save</button>
                <button style="flex:1; background:var(--accent); color:#000;" onclick="importData()">Load Save</button>
            </div>
            <div id="ioMsg" style="text-align:center; color: var(--accent); font-size:0.8rem; margin-top:8px;"></div>
        </div>
    </div>

</div>

<script>
    let isPopulating = false; // Guard to prevent saving during initial load
    const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
    const skillsMap = {
        'acrobatics': 'dex', 'animal handling': 'wis', 'arcana': 'int', 'athletics': 'str', 
        'deception': 'cha', 'history': 'int', 'insight': 'wis', 'intimidation': 'cha', 
        'investigation': 'int', 'medicine': 'wis', 'nature': 'int', 'perception': 'wis', 
        'performance': 'cha', 'persuasion': 'cha', 'religion': 'int', 'sleight of hand': 'dex', 
        'stealth': 'dex', 'survival': 'wis'
    };

    const spellSlotTable = {
        full: [
            [2], [3], [4,2], [4,3], [4,3,2], [4,3,3], [4,3,3,1], [4,3,3,2], [4,3,3,3,1], [4,3,3,3,2],
            [4,3,3,3,2,1], [4,3,3,3,2,1], [4,3,3,3,2,1,1], [4,3,3,3,2,1,1], [4,3,3,3,2,1,1,1], [4,3,3,3,2,1,1,1],
            [4,3,3,3,2,1,1,1,1], [4,3,3,3,3,1,1,1,1], [4,3,3,3,3,2,1,1,1], [4,3,3,3,3,2,2,1,1]
        ],
        pact: [
            [1], [2], [2], [2], [2], [2], [2], [2], [2], [2],
            [3], [3], [3], [3], [3], [3], [4], [4], [4], [4]
        ]
    };

    let allData = { 
        activeId: 'char_default',
        characters: {}
    };
    
    let data = {}; 

    let consumeInspirationOnNextRoll = false;
    let secretMode = false;

    // --- ACCORDION LOGIC ---
    function toggleSection(key) {
        const head = document.getElementById('head-' + key);
        const body = document.getElementById('body-' + key);
        const card = document.getElementById('card-' + key);
        
        head.classList.toggle('collapsed');
        body.classList.toggle('collapsed');
        
        const isOpen = !body.classList.contains('collapsed');
        
        if (isOpen) {
            if(card) card.classList.remove('card-collapsed');
        } else {
            if(card) card.classList.add('card-collapsed');
        }
        
        data.uiState[key] = isOpen;
        save();
    }

    // --- CHARACTER SWITCHING LOGIC ---
    function getDefaultChar() {
        let char = {
            meta: { player: '', name: 'New Character', level: 1, casterType: 'none', webhook: '', discordActive: false, init: 0, speed: '' },
            vitals: { 
                curr: '', max: '', temp: '', 
                hdDie: 'd8', hdCurr: 1, hdMax: 1,
                inspiration: 0, 
                ds: {s1:false, s2:false, s3:false, f1:false, f2:false, f3:false} 
            },
            ac: { mode: 'std', dexCap: '100', base: 10, bonus: 0, customStat1: 'dex', customStat2: 'none', bonuses: [] },
            stats: { str: {val:10,save:false}, dex: {val:10,save:false}, con: {val:10,save:false}, int: {val:10,save:false}, wis: {val:10,save:false}, cha: {val:10,save:false} },
            skills: {}, 
            skillOverrides: {}, 
            skillMisc: {}, // NEW: Store manual skill bonuses
            attacks: [], features: [], spells: [], resources: [], rollMode: 'norm',
            uiState: { cardOrder: [] }
        };
        Object.keys(skillsMap).forEach(s => char.skills[s] = 0);
        for(let i=1; i<=9; i++) char.spells.push({ lvl: i, max: 0, used: 0 });
        return char;
    }

    function refreshCharSelect() {
        const sel = document.getElementById('charSelect');
        sel.innerHTML = '';
        Object.keys(allData.characters).forEach(key => {
            const char = allData.characters[key];
            const opt = document.createElement('option');
            opt.value = key;
            opt.text = (char.meta && char.meta.name) ? char.meta.name : "Unnamed";
            if (key === allData.activeId) opt.selected = true;
            sel.appendChild(opt);
        });
    }

    function switchCharacter(id) {
        allData.characters[allData.activeId] = data; 
        saveGlobal();
        allData.activeId = id;
        loadActiveChar();
    }

    function createNewCharacter() {
        allData.characters[allData.activeId] = data;
        const newId = 'char_' + Date.now();
        allData.characters[newId] = getDefaultChar();
        allData.activeId = newId;
        saveGlobal();
        loadActiveChar();
    }

    function deleteCharacter() {
        const ids = Object.keys(allData.characters);
        if (ids.length <= 1) {
            alert("Cannot delete the last character.");
            return;
        }
        if (!confirm("Delete this character permanently?")) return;
        delete allData.characters[allData.activeId];
        allData.activeId = Object.keys(allData.characters)[0];
        saveGlobal();
        loadActiveChar();
    }

    function loadActiveChar() {
        data = allData.characters[allData.activeId];
        refreshCharSelect();
        populateUI(); 
    }

    // --- INITIALIZATION ---
    function init() {
        const v3 = localStorage.getItem('unifiedSheetDataV3');
        if (v3) {
            allData = JSON.parse(v3);
        } else {
            const v2 = localStorage.getItem('unifiedSheetDataV2');
            if (v2) {
                const oldChar = JSON.parse(v2);
                const id = 'char_imported';
                allData = { activeId: id, characters: {} };
                allData.characters[id] = oldChar;
                if (!allData.characters[id].uiState) allData.characters[id].uiState = {};
            } else {
                const id = 'char_default';
                allData = { activeId: id, characters: {} };
                allData.characters[id] = getDefaultChar();
            }
            saveGlobal();
        }
        loadActiveChar();
        setupDragAndDrop();
    }

    function populateUI() {
        isPopulating = true;
        if (!data.meta) data.meta = {};
        if (!data.vitals) data.vitals = {};
        if (!data.uiState) data.uiState = {};
        if (!data.skillMisc) data.skillMisc = {};
        if (!data.skillOverrides) data.skillOverrides = {};

        document.getElementById('playerName').value = data.meta.player || '';
        document.getElementById('charName').value = data.meta.name || '';
        document.getElementById('charLevel').value = data.meta.level || 1;
        document.getElementById('casterType').value = data.meta.casterType || 'none';
        document.getElementById('webhookUrl').value = data.meta.webhook || '';
        document.getElementById('sendToDiscord').checked = data.meta.discordActive || false;
    
        document.getElementById('initBonus').value = data.meta.init || "+0";
        document.getElementById('speedVal').value = data.meta.speed || '';
    
        toggleDiscord(data.meta.discordActive);

        // FIX: Use (val !== undefined) check instead of (|| '') to allow 0 to persist
        document.getElementById('hpCurr').value = (data.vitals.curr !== undefined && data.vitals.curr !== null) ? data.vitals.curr : '';
        document.getElementById('hpMax').value = (data.vitals.max !== undefined && data.vitals.max !== null) ? data.vitals.max : '';
        document.getElementById('hpTemp').value = (data.vitals.temp !== undefined && data.vitals.temp !== null) ? data.vitals.temp : '';
        document.getElementById('inspirationVal').value = data.vitals.inspiration || 0;
    
        document.getElementById('hdDie').value = data.vitals.hdDie || 'd8';
        document.getElementById('hdCurr').value = (data.vitals.hdCurr !== undefined) ? data.vitals.hdCurr : 1;
        document.getElementById('hdMax').value = (data.vitals.hdMax !== undefined) ? data.vitals.hdMax : 1;

        if (!data.vitals.ds) data.vitals.ds = {s1:false, s2:false, s3:false, f1:false, f2:false, f3:false};
        document.getElementById('ds-s1').checked = data.vitals.ds.s1;
        document.getElementById('ds-s2').checked = data.vitals.ds.s2;
        document.getElementById('ds-s3').checked = data.vitals.ds.s3;
        document.getElementById('ds-f1').checked = data.vitals.ds.f1;
        document.getElementById('ds-f2').checked = data.vitals.ds.f2;
        document.getElementById('ds-f3').checked = data.vitals.ds.f3;

        document.getElementById('acBase').value = data.ac.base || 10;
        document.getElementById('acDexCap').value = data.ac.dexCap || 100;
        document.getElementById('acCustomToggle').checked = (data.ac.mode === 'custom');
        
        populateStatSelects();
        document.getElementById('acStat1').value = data.ac.customStat1 || 'dex';
        document.getElementById('acStat2').value = data.ac.customStat2 || 'none';
        
        toggleACMode(); 
        renderAcList();

        if (data.uiState.cardOrder && data.uiState.cardOrder.length > 0) {
            const container = document.querySelector('.sheet-container');
            const sortedFrag = document.createDocumentFragment();
            data.uiState.cardOrder.forEach(id => {
                const el = document.getElementById(id);
                if (el) sortedFrag.appendChild(el);
            });
            Array.from(container.children).forEach(child => {
                if (child.classList.contains('card') && !data.uiState.cardOrder.includes(child.id)) {
                    sortedFrag.appendChild(child);
                }
            });
            container.appendChild(sortedFrag);
        }

        const accKeys = ['combat', 'attr', 'atk', 'feats', 'spells', 'skills', 'roller', 'io'];
        accKeys.forEach(key => {
            const isClosed = data.uiState[key] === false; 
            const card = document.getElementById('card-' + key);
            if (isClosed) {
                document.getElementById('head-'+key).classList.add('collapsed');
                document.getElementById('body-'+key).classList.add('collapsed');
                if (card) card.classList.add('card-collapsed');
            } else {
                if (card) card.classList.remove('card-collapsed');
                document.getElementById('head-'+key).classList.remove('collapsed');
                document.getElementById('body-'+key).classList.remove('collapsed');
            }
        });

        updateHP(); 
        renderStats();
        renderSkills();
        renderAttacks();
        renderFeatures();
        renderSpells();
        renderResources();
        updateAll();
        setMode(data.rollMode || 'norm');
        isPopulating = false;
    }

    function saveGlobal() {
        localStorage.setItem('unifiedSheetDataV3', JSON.stringify(allData));
    }

    function save() {
        if (isPopulating) return;
        data.meta.player = document.getElementById('playerName').value;
        data.meta.name = document.getElementById('charName').value;
        data.meta.webhook = document.getElementById('webhookUrl').value;
    
        // FIX: Convert HP to numbers during save to ensure clean data
        data.vitals.curr = parseInt(document.getElementById('hpCurr').value);
        data.vitals.max = parseInt(document.getElementById('hpMax').value);
        data.vitals.temp = parseInt(document.getElementById('hpTemp').value) || 0;
    
        data.vitals.inspiration = parseInt(document.getElementById('inspirationVal').value) || 0;
        data.meta.speed = document.getElementById('speedVal').value;
        data.vitals.hdDie = document.getElementById('hdDie').value;
        data.vitals.hdCurr = parseInt(document.getElementById('hdCurr').value) || 0;
        data.vitals.hdMax = parseInt(document.getElementById('hdMax').value) || 0;
        data.meta.casterType = document.getElementById('casterType').value;

        if(document.getElementById('ds-s1')) {
            data.vitals.ds = {
                s1: document.getElementById('ds-s1').checked,
                s2: document.getElementById('ds-s2').checked,
                s3: document.getElementById('ds-s3').checked,
                f1: document.getElementById('ds-f1').checked,
                f2: document.getElementById('ds-f2').checked,
                f3: document.getElementById('ds-f3').checked,
            };
        }

        const sel = document.getElementById('charSelect');
        const activeOpt = sel.querySelector(`option[value="${allData.activeId}"]`);
        if(activeOpt && activeOpt.text !== data.meta.name) {
            activeOpt.text = data.meta.name || "Unnamed";
        }

        allData.characters[allData.activeId] = data;
        saveGlobal();
    }

    // --- DICE & LOGIC ---
    function toggleSecret() {
        secretMode = !secretMode;
        const btn = document.getElementById('btnSecret');
        if(secretMode) {
            btn.classList.add('active');
            btn.innerHTML = 'üôà';
        } else {
            btn.classList.remove('active');
            btn.innerHTML = 'üëÅÔ∏è';
        }
    }

    function parseRollModifiers(str) {
        let mods = { r: 0, dl: 0, kh: 0 };
        if (!str) return mods;
        const rMatch = str.match(/r(\d+)/);
        if (rMatch) mods.r = parseInt(rMatch[1]);
        const dlMatch = str.match(/d[l]?(\d+)/); 
        if (dlMatch) mods.dl = parseInt(dlMatch[1]);
        const khMatch = str.match(/k[h]?(\d+)/);
        if (khMatch) mods.kh = parseInt(khMatch[1]);
        return mods;
    }

    function coreRoll(count, sides, mode = 'norm', mods = {}) {
        let rolls = [];
        let total = 0;
        let isCrit = false;
        let isFail = false;
        let formula = "";

        if (count === 1 && sides === 20 && mode !== 'norm') {
            const r1 = Math.floor(Math.random() * sides) + 1;
            const r2 = Math.floor(Math.random() * sides) + 1;
            rolls = [r1, r2];
            
            if (mode === 'adv') {
                total = Math.max(r1, r2);
                formula = `[${r1}, ${r2}] (High)`;
            } else {
                total = Math.min(r1, r2);
                formula = `[${r1}, ${r2}] (Low)`;
            }
            if (total === 20) isCrit = true;
            if (total === 1) isFail = true;
        } else {
            let rollObjs = [];
            for(let i=0; i<count; i++) {
                let r = Math.floor(Math.random() * sides) + 1;
                if (mods.r > 0) {
                    let safety = 0;
                    while (r <= mods.r && safety < 50) {
                        r = Math.floor(Math.random() * sides) + 1;
                        safety++;
                    }
                }
                rollObjs.push({ val: r, dropped: false, originalIdx: i });
            }

            if (mods.dl > 0 || mods.kh > 0) {
                let sorted = [...rollObjs].sort((a,b) => a.val - b.val);
                let dropCount = mods.dl;
                if (mods.kh > 0) {
                    let calculatedDrop = count - mods.kh;
                    if (calculatedDrop > dropCount) dropCount = calculatedDrop;
                }
                for(let i=0; i<dropCount; i++) {
                    if (sorted[i]) sorted[i].dropped = true;
                }
            }

            let valList = [];
            rollObjs.forEach(obj => {
                if (!obj.dropped) total += obj.val;
                valList.push(obj.dropped ? `~~${obj.val}~~` : obj.val);
            });
            
            if (count === 1 && sides === 20 && total === 20) isCrit = true;
            if (count === 1 && sides === 20 && total === 1) isFail = true;

            formula = `[${valList.join('+')}]`;
        }

        return { total, rolls: rolls, formula, isCrit, isFail };
    }

    function parseComplexBonus(str) {
        if (!str) return { total: 0, text: '' };
        let total = 0;
        let parts = [];
        const diceRegex = /([+-]?)\s*(\d+)d(\d+)\s*([a-z0-9]*)/gi;
        let match;
        let diceMatches = [];
        while ((match = diceRegex.exec(str)) !== null) { diceMatches.push(match); }

        diceMatches.forEach(m => {
             const sign = (m[1].trim() === '-') ? -1 : 1;
             const count = parseInt(m[2]);
             const sides = parseInt(m[3]);
             const modStr = m[4] || ""; 
             
             const mods = parseRollModifiers(modStr);
             const res = coreRoll(count, sides, 'norm', mods);
             
             total += (res.total * sign);
             const signStr = sign === -1 ? '-' : '+';
             let form = res.formula; 
             if (modStr) form += `${modStr}`; 
             parts.push(`${signStr}${form}`);
        });

        let cleanStr = str.replace(diceRegex, '');
        const staticRegex = /([+-]?)\s*(\d+)/gi;
        while ((match = staticRegex.exec(cleanStr)) !== null) {
             const sign = (match[1].trim() === '-') ? -1 : 1;
             const val = parseInt(match[2]);
             total += (val * sign);
             parts.push(`${sign===-1?'-':'+'}${val}`);
        }

        return { total, text: parts.join(' ') };
    }

    // --- CALCULATION LOGIC ---
    function getMod(score) { return Math.floor((score - 10) / 2); }
    function getPB(level) { return Math.ceil(level / 4) + 1; }
    function updateLevel(val) { data.meta.level = Math.min(20, Math.max(1, parseInt(val))); save(); updateAll(); }

    function updateAll() {
        const pb = getPB(data.meta.level);
    
        stats.forEach(s => {
            const mod = getMod(data.stats[s].val);
            const saveBonus = mod + (data.stats[s].save ? pb : 0);
            document.getElementById(`mod-${s}`).innerText = (mod >= 0 ? "+" : "") + mod;
            document.getElementById(`def-${s}`).innerText = 11 + saveBonus;
        });
    
        Object.keys(skillsMap).forEach(s => {
            const defaultStat = skillsMap[s];
            const activeStat = (data.skillOverrides && data.skillOverrides[s]) ? data.skillOverrides[s] : defaultStat;
        
            const mod = getMod(data.stats[activeStat].val);
            const profLevel = data.skills[s] || 0;
        
            // NEW: Add Misc Bonus
            const misc = getSkillMiscBonus(s);
        
            const bonus = mod + (profLevel * pb) + misc;
            document.getElementById(`skill-bonus-${s}`).innerText = (bonus >= 0 ? "+" : "") + bonus;
        });
    
        const statsArr = ['int', 'wis', 'cha'];
        let maxMod = -5;
        statsArr.forEach(s => { const m = getMod(data.stats[s].val); if(m > maxMod) maxMod = m; });
        document.getElementById('globalDC').innerText = 8 + pb + maxMod;
    
        updateAC();
    }

    // --- AC LOGIC ---
    function populateStatSelects() {
        const s1 = document.getElementById('acStat1');
        const s2 = document.getElementById('acStat2');
        const ops = stats.map(s => `<option value="${s}">${s.toUpperCase()}</option>`).join('');
        const opsNone = `<option value="none">None</option>` + ops;
        s1.innerHTML = ops;
        s2.innerHTML = opsNone;
    }

    function toggleACMode() {
        const isCustom = document.getElementById('acCustomToggle').checked;
        data.ac.mode = isCustom ? 'custom' : 'std';
        document.getElementById('acStdControls').style.display = isCustom ? 'none' : 'grid';
        document.getElementById('acCustomControls').style.display = isCustom ? 'grid' : 'none';
        save(); updateAC();
    }

    function updateAC() {
        data.ac.base = parseInt(document.getElementById('acBase').value) || 10;
        data.ac.dexCap = parseInt(document.getElementById('acDexCap').value);
        data.ac.customStat1 = document.getElementById('acStat1').value;
        data.ac.customStat2 = document.getElementById('acStat2').value;

        let bonusTotal = 0;
        data.ac.bonuses.forEach(b => { if (b.active) bonusTotal += (parseInt(b.val) || 0); });

        let total = 0;
        if (data.ac.mode === 'std') {
            const rawDex = getMod(data.stats.dex.val);
            let effectiveDex = rawDex;
            if (data.ac.dexCap !== 100) { 
                if (data.ac.dexCap === 0) effectiveDex = 0; 
                else effectiveDex = Math.min(rawDex, data.ac.dexCap);
            }
            document.getElementById('acDexModDisp').innerText = (effectiveDex >= 0 ? "+" : "") + effectiveDex;
            total = data.ac.base + effectiveDex + bonusTotal;
        } else {
            const m1 = getMod(data.stats[data.ac.customStat1].val);
            let m2 = 0;
            if (data.ac.customStat2 !== 'none') { m2 = getMod(data.stats[data.ac.customStat2].val); }
            total = 10 + m1 + m2 + bonusTotal;
        }
        document.getElementById('acTotalDisplay').innerText = total;
        save();
    }

    function renderAcList() {
        const list = document.getElementById('acBonusList');
        list.innerHTML = data.ac.bonuses.map((b, i) => `
            <div class="ac-row ${b.active ? '' : 'inactive'}">
                <label class="toggle-switch"><input type="checkbox" ${b.active ? 'checked' : ''} onchange="toggleAcBonus(${i})"><span class="slider"></span></label>
                <input type="text" value="${b.name}" placeholder="Source (Shield)" onchange="updateAcBonus(${i}, 'name', this.value)">
                <input type="number" class="ac-val-input" value="${b.val}" placeholder="+0" onchange="updateAcBonus(${i}, 'val', this.value)">
                <button class="btn-del" style="margin-left:auto;" onclick="delAcBonus(${i})">&times;</button>
            </div>
        `).join('');
    }
    function addAcBonus() { data.ac.bonuses.push({ id: Date.now(), name: '', val: 1, active: true }); renderAcList(); updateAC(); }
    function toggleAcBonus(i) { data.ac.bonuses[i].active = !data.ac.bonuses[i].active; renderAcList(); updateAC(); }
    function updateAcBonus(i, field, val) { data.ac.bonuses[i][field] = val; updateAC(); }
    function delAcBonus(i) { data.ac.bonuses.splice(i, 1); renderAcList(); updateAC(); }

    // --- HP LOGIC ---
    function updateHP() {
        const curr = parseInt(document.getElementById('hpCurr').value) || 0;
        const max = parseInt(document.getElementById('hpMax').value) || 0;
        const temp = parseInt(document.getElementById('hpTemp').value) || 0;
        
        let currPct = 0; if(max > 0) currPct = (curr / max) * 100;
        if(currPct > 100) currPct = 100; if(currPct < 0) currPct = 0;
        let tempPct = 0; if(max > 0) tempPct = (temp / max) * 100;
        if(tempPct > 100) tempPct = 100;
        
        document.getElementById('barCurr').style.width = currPct + "%";
        document.getElementById('barTemp').style.width = tempPct + "%";
        document.getElementById('barText').innerText = `${curr} / ${max}` + (temp > 0 ? ` (+${temp})` : "");
        
        const dsRow = document.getElementById('deathSaveRow');
        if (curr <= 0 && max > 0) dsRow.style.display = 'grid'; else dsRow.style.display = 'none';
        save();
    }

    function modifyHP(isDamage, fixedAmt = null) {
        const interactInput = document.getElementById('hpInteractVal');
        let amt = 0;
        if (fixedAmt !== null) amt = fixedAmt; else amt = parseInt(interactInput.value) || 0;
        if (amt <= 0) return;

        let curr = parseInt(document.getElementById('hpCurr').value) || 0;
        let max = parseInt(document.getElementById('hpMax').value) || 0;
        let temp = parseInt(document.getElementById('hpTemp').value) || 0;

        if (isDamage) {
            if (temp > 0) {
                if (amt >= temp) { amt -= temp; temp = 0; } else { temp -= amt; amt = 0; }
            }
            curr = Math.max(0, curr - amt);
        } else {
            curr += amt;
            if (max > 0 && curr > max) curr = max;
        }
        document.getElementById('hpTemp').value = temp;
        document.getElementById('hpCurr').value = curr;
        if (fixedAmt === null) interactInput.value = ''; 
        updateHP();
    }

    // --- ROLLING / INSPIRATION / REST ---
    function rollHitDie() {
        let currHD = parseInt(document.getElementById('hdCurr').value) || 0;
        const maxHD = parseInt(document.getElementById('hdMax').value) || 0;
        if (currHD <= 0) { alert("No Hit Dice remaining!"); return; }

        const dieStr = document.getElementById('hdDie').value || "d8";
        const sides = parseInt(dieStr.replace(/\D/g,'')) || 8; 
        const conMod = getMod(data.stats.con.val);

        const result = coreRoll(1, sides);
        const rollVal = result.rolls[0].val;
        const total = Math.max(0, rollVal + conMod); 

        let hpCurr = parseInt(document.getElementById('hpCurr').value) || 0;
        const hpMax = parseInt(document.getElementById('hpMax').value) || 0;
        const oldHp = hpCurr;
        
        hpCurr += total;
        if (hpMax > 0 && hpCurr > hpMax) hpCurr = hpMax;
        
        currHD--;
        document.getElementById('hpCurr').value = hpCurr;
        document.getElementById('hdCurr').value = currHD;
        
        updateHP(); save();
        const formula = `[${rollVal}] ${conMod>=0?'+':''}${conMod} (Con)`;
        showLog(formula, total);
        sendToDiscord("Short Rest", `Used 1${dieStr}. Formula: ${formula}`, `**Healed ${hpCurr - oldHp} HP**`, 'check');
    }
    
    function shortRest() {
        if(!confirm("SHORT REST\n\n- Reset SR Counters?\n(Hit Dice must be rolled manually)")) return;
        data.resources.forEach(r => { if(r.rest === 'sr') r.curr = r.max; });
        const type = data.meta.casterType || 'none';
        if(type === 'pact') {
            data.spells.forEach(s => s.used = 0);
            showLog("Pact Magic", "Slots Reset");
        }
        save(); renderResources(); renderSpells(); showLog("Short Rest", "Counters Reset");
    }

    function longRest() {
        if(!confirm("LONG REST\n\n- Reset HP to Max\n- Reset Spell Slots\n- Regain ¬Ω Max Hit Dice\n- Reset Death Saves\n- Reset SR/LR Counters")) return;
        document.getElementById('hpCurr').value = document.getElementById('hpMax').value;
        document.getElementById('hpTemp').value = 0;
        data.spells.forEach(s => s.used = 0);
        let hdCurr = parseInt(document.getElementById('hdCurr').value) || 0;
        const hdMax = parseInt(document.getElementById('hdMax').value) || 0;
        hdCurr = Math.min(hdMax, hdCurr + Math.max(1, Math.floor(hdMax / 2)));
        document.getElementById('hdCurr').value = hdCurr;
        data.vitals.ds = {s1:false, s2:false, s3:false, f1:false, f2:false, f3:false};
        data.resources.forEach(r => { if(r.rest === 'sr' || r.rest === 'lr') r.curr = r.max; });
        save(); init(); showLog("Long Rest", "Completed");
    }

    function useInspiration() {
        let val = parseInt(document.getElementById('inspirationVal').value) || 0;
        if(val <= 0) { showLog("No Insp!", "0"); return; }
        val--;
        document.getElementById('inspirationVal').value = val;
        data.vitals.inspiration = val;
        save();
        consumeInspirationOnNextRoll = true;
        setMode('adv');
        document.getElementById('rollerBar').classList.add('insp-active');
        showLog("Inspiration!", "Active");
    }
    function consumeInspiration() {
        if(consumeInspirationOnNextRoll) { 
            consumeInspirationOnNextRoll = false; 
            setMode('norm'); 
            document.getElementById('rollerBar').classList.remove('insp-active');
        }
    }
    function setMode(mode) {
        data.rollMode = mode;
        save(); 
        document.querySelectorAll('.adv-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`.adv-btn[data-mode="${mode}"]`).classList.add('active');
    }

    function showLog(formula, result, isCrit = false, isFail = false) {
        const logArea = document.getElementById('logArea');
        let resClass = 'log-result';
        if(isCrit) resClass += ' crit-text';
        if(isFail) resClass += ' fail-text';
        logArea.innerHTML = `<div class="log-formula">${formula}</div><div class="${resClass}">${result}</div>`;
    }

    function rollDie(sides, bonus, label, allowAdvantage = true, type = 'check', customDesc = '') {
        const miscStr = document.getElementById('globalMisc').value.trim();
        const parsedMisc = parseComplexBonus(miscStr);
        let effectiveMode = data.rollMode;
        let consumedInsp = false;
        
        if(allowAdvantage && consumeInspirationOnNextRoll) { effectiveMode = 'adv'; consumedInsp = true; }
        const result = coreRoll(1, sides, allowAdvantage ? effectiveMode : 'norm');
        const total = result.total + bonus + parsedMisc.total;
        
        let formulaText = result.formula;
        if(bonus !== 0) formulaText += ` ${bonus>=0?'+':''}${bonus}`;
        if(parsedMisc.total !== 0) formulaText += ` ${parsedMisc.text} (Misc)`;
        if(allowAdvantage && effectiveMode !== 'norm') formulaText += ` (${effectiveMode.toUpperCase()})`;

        showLog(formulaText, total, result.isCrit, result.isFail);
        sendToDiscord(label + (effectiveMode!=='norm' && allowAdvantage ? ` (${effectiveMode.toUpperCase()})` : ''), `Dice: ${formulaText}`, `**${total}**`, type, customDesc);
        if(consumedInsp) consumeInspiration();
    }

    function rollCustom() {
        const formula = document.getElementById('customFormula').value.trim();
        const label = document.getElementById('customLabel').value.trim() || 'Custom Roll';
        const parsed = parseComplexBonus(formula);
        if(parsed.text === '') { showLog("Error", "Invalid"); return; }
        showLog(parsed.text, parsed.total);
        sendToDiscord(label + ": " + formula, `Dice: ${parsed.text}`, `**${parsed.total}**`, 'dmg');
    }

    function rollDamage(idx) {
        const atk = data.attacks[idx];
        let mod = 0;
        if (atk.stat !== 'none') { mod = getMod(data.stats[atk.stat].val); }
        const miscStr = document.getElementById('globalMisc').value.trim();
        const dmgStr = (atk.dmg || "") + " " + miscStr;
        const parsed = parseComplexBonus(dmgStr);
        if(parsed.text === '') return;
        let total = parsed.total + mod;
        let formulaText = parsed.text;
        if (mod !== 0) { formulaText += ` ${mod>=0?'+':''}${mod} (${atk.stat.toUpperCase()})`; }
        showLog(formulaText, total);
        sendToDiscord((atk.name || 'Weapon') + " Damage", `Dice: ${formulaText}`, `**${total}**`, 'dmg', atk.desc);
    }

    function rollInitiative() {
        const initStr = document.getElementById('initBonus').value.trim();
        const miscStr = document.getElementById('globalMisc').value.trim();
        data.meta.init = initStr; save();

        const dexMod = getMod(data.stats.dex.val);
        const parsedInit = parseComplexBonus(initStr);
        const parsedMisc = parseComplexBonus(miscStr);
        const tieBreaker = data.stats.dex.val / 100;

        let effectiveMode = data.rollMode;
        let consumedInsp = false;
        if(consumeInspirationOnNextRoll) { effectiveMode = 'adv'; consumedInsp = true; }

        const result = coreRoll(1, 20, effectiveMode);
        const total = result.total + dexMod + parsedInit.total + parsedMisc.total;
        const finalScore = (total + tieBreaker).toFixed(2);

        let formulaText = `${result.formula} ${dexMod>=0?'+':''}${dexMod} (Dex)`;
        if(parsedInit.total !== 0) formulaText += ` ${parsedInit.text} (Init)`;
        if(parsedMisc.total !== 0) formulaText += ` ${parsedMisc.text} (Misc)`;
        if(effectiveMode !== 'norm') formulaText += ` (${effectiveMode.toUpperCase()})`;

        showLog(`Init`, finalScore);
        sendToDiscord("Initiative", `Dice: ${formulaText}`, `**${finalScore}**`, 'check');
        if(consumedInsp) consumeInspiration();
    }

    function rollDeathSave() {
        const r = Math.floor(Math.random() * 20) + 1;
        let msg = "Failure";
        let isCrit = false; let isFail = false;
        if (r === 20) { msg = "Regain 1 HP!"; isCrit = true; document.getElementById('hpCurr').value = 1; updateHP(); }
        else if (r === 1) { msg = "2 Failures"; isFail = true; updateDS('f'); updateDS('f'); }
        else if (r >= 10) { msg = "Success"; isCrit = true; updateDS('s'); }
        else { msg = "Failure"; isFail = true; updateDS('f'); }
        showLog("Death Save", r, isCrit, isFail);
        sendToDiscord("Death Save", `Rolled: ${r}`, `**${msg}**`, 'save');
    }
    
    function updateDS(type) {
        const d = data.vitals.ds;
        for(let i=1; i<=3; i++) { if(!d[type+i]) { d[type+i] = true; break; } }
        save(); init();
    }

    // --- RENDERERS ---
    function renderStats() {
        document.getElementById('statsGrid').innerHTML = stats.map(s => `
            <div class="stat-card">
                <h3>${s.toUpperCase()}</h3>
                <input type="number" class="score-input" value="${data.stats[s].val}" onchange="updateStat('${s}', this.value)">
                <div class="mod-display" id="mod-${s}">+0</div>
                <div class="save-prof" onclick="toggleSave('${s}', event)"><input type="checkbox" ${data.stats[s].save ? 'checked' : ''}> Def Prof</div>
                <div class="defense-box"><div class="defense-val" id="def-${s}">11</div></div>
                
                <div class="stat-btn-row">
                    <button class="btn-sm-roll" onclick="rollCheck('${s}')">Check</button>
                    <button class="btn-sm-save" onclick="rollSave('${s}')">Save</button>
                </div>
            </div>
        `).join('');
    }

    function renderSkills() {
        document.getElementById('skillGrid').innerHTML = Object.keys(skillsMap).map(s => {
            const state = data.skills[s] || 0; 
            const icon = state === 2 ? '‚óà' : (state === 1 ? '‚óÜ' : '‚óá');
            const cls = state === 2 ? 'exp' : (state === 1 ? 'prof' : '');
        
            const defaultStat = skillsMap[s];
            const activeStat = (data.skillOverrides && data.skillOverrides[s]) ? data.skillOverrides[s] : defaultStat;
            const isOverridden = (activeStat !== defaultStat);
        
            // NEW: Get saved misc value
            const miscVal = (data.skillMisc && data.skillMisc[s]) ? data.skillMisc[s] : "";

            return `
            <div class="skill-row">
                <span class="prof-toggle ${cls}" onclick="cycleSkill('${s}')">${icon}</span>
                <span class="skill-attr ${isOverridden ? 'overridden' : ''}" onclick="cycleSkillAttr('${s}')" title="Click to change Attribute">${activeStat.toUpperCase().substr(0,3)}</span>
                <span class="skill-name">${s.charAt(0).toUpperCase() + s.slice(1)}</span>
            
                <span style="font-weight:bold; color:#ddd;" id="skill-bonus-${s}">+0</span>
            
                <input type="text" class="skill-misc" placeholder="+0" value="${miscVal}" onchange="updateSkillMisc('${s}', this.value)" title="Enter flat bonus (2) or stat name (cha)">
            
                <button class="btn-roll-skill" onclick="rollSkill('${s}')">üé≤</button>
            </div>`;
        }).join('');
    }

    function updateSkillMisc(skill, val) {
        if(!data.skillMisc) data.skillMisc = {};
        data.skillMisc[skill] = val.toLowerCase().trim();
        save();
        updateAll();
    }

    function getSkillMiscBonus(skill) {
    if (!data.skillMisc || !data.skillMisc[skill]) return 0;
        const val = data.skillMisc[skill];
    
        // Check if it's a stat name (e.g. "cha", "int")
        if (stats.includes(val)) {
            return getMod(data.stats[val].val);
        }
        
        // Otherwise parse as number
        return parseInt(val) || 0;
    }

    function renderAttacks() {
        document.getElementById('attackList').innerHTML = data.attacks.map((atk, i) => `
            <div class="atk-row">
                <input class="atk-name-input" type="text" placeholder="Weapon Name" value="${atk.name}" onchange="updateAttack(${i}, 'name', this.value)">
                <div class="atk-stats-line">
                    <input type="text" placeholder="1d8" value="${atk.dmg}" onchange="updateAttack(${i}, 'dmg', this.value)">
                    <select onchange="updateAttack(${i}, 'stat', this.value)">
                        <option value="none" ${atk.stat === 'none' ? 'selected' : ''}>NONE</option>
                        ${stats.map(s => `<option value="${s}" ${atk.stat === s ? 'selected' : ''}>${s.toUpperCase()}</option>`).join('')}
                    </select>
                </div>
                <textarea class="atk-desc" placeholder="Attack description / effect..." onchange="updateAttack(${i}, 'desc', this.value)">${atk.desc || ''}</textarea>
                <div class="atk-controls">
                    <button style="background:var(--accent); color:#000;" onclick="rollAttack(${i})">Atk</button>
                    <button style="background:#333; color:#ccc; border:1px solid #444;" onclick="rollDamage(${i})">Dmg</button>
                    <button style="background:transparent; color:#666; font-size:1.5rem;" onclick="delAttack(${i})">&times;</button>
                </div>
            </div>
        `).join('');
    }
    
    function renderFeatures() {
        document.getElementById('featureList').innerHTML = data.features.map((feat, i) => `
            <div class="atk-row">
                <input class="atk-name-input" type="text" placeholder="Feature Name" value="${feat.name}" onchange="updateFeature(${i}, 'name', this.value)">
                <textarea class="atk-desc" style="min-height:60px;" placeholder="Feature description..." onchange="updateFeature(${i}, 'desc', this.value)">${feat.desc || ''}</textarea>
                <div class="atk-controls" style="grid-template-columns: 1fr auto;">
                    <button style="background:var(--accent-feat); color:#fff;" onclick="postFeature(${i})">üì¢ Post to Chat</button>
                    <button style="background:transparent; color:#666; font-size:1.5rem;" onclick="delFeature(${i})">&times;</button>
                </div>
            </div>
        `).join('');
    }

    function renderSpells() {
        const list = document.getElementById('spellSlotsList');
        list.innerHTML = '';
        data.spells.forEach((slot, idx) => {
            let bubblesHtml = '';
            for(let i=0; i<slot.max; i++) {
                const isUsed = i < slot.used;
                bubblesHtml += `<div class="bubble ${isUsed ? 'used' : ''}" onclick="toggleSpellSlot(${idx}, ${i})"></div>`;
            }
            const div = document.createElement('div');
            div.className = 'spell-row';
            div.innerHTML = `
                <div class="spell-lvl">Lvl ${slot.lvl}</div>
                <input type="number" class="spell-max" value="${slot.max}" placeholder="0" onchange="updateSpellMax(${idx}, this.value)">
                <div class="spell-bubbles">${bubblesHtml}</div>
            `;
            list.appendChild(div);
        });
    }

    function calcSpellSlots() {
        const type = document.getElementById('casterType').value;
        const lvl = parseInt(document.getElementById('charLevel').value) || 1;
        
        if (type === 'none') {
             if(!confirm("Clear all spell slots?")) return;
             data.spells.forEach(s => s.max = 0);
             save(); renderSpells(); return;
        }

        let effectiveLvl = 0;
        let tableToUse = spellSlotTable.full;

        if (type === 'full') effectiveLvl = lvl;
        else if (type === 'half') effectiveLvl = Math.floor(lvl / 2);
        else if (type === 'third') effectiveLvl = Math.ceil(lvl / 3);
        else if (type === 'pact') {
            effectiveLvl = lvl;
            tableToUse = spellSlotTable.pact;
        }

        effectiveLvl = Math.max(0, Math.min(20, effectiveLvl));

        if (effectiveLvl === 0) {
            data.spells.forEach(s => s.max = 0);
        } else {
            const slots = tableToUse[effectiveLvl - 1] || [];
            if (type === 'pact') {
                let slotLvl = 1;
                if(lvl >= 3) slotLvl = 2;
                if(lvl >= 5) slotLvl = 3;
                if(lvl >= 7) slotLvl = 4;
                if(lvl >= 9) slotLvl = 5;
                const slotCount = slots[0]; 
                data.spells.forEach(s => s.max = 0);
                if (data.spells[slotLvl-1]) data.spells[slotLvl-1].max = slotCount;
            } else {
                data.spells.forEach((s, i) => {
                    s.max = slots[i] || 0;
                });
            }
        }
        
        save(); renderSpells();
        showLog("Slots", "Updated");
    }

    function renderResources() {
        const list = document.getElementById('resourceList');
        list.innerHTML = data.resources.map((res, i) => {
            const display = res.display || 'none';
            const rest = res.rest || 'none';
            let vizHtml = '';
            if (display === 'bar') {
                let pct = 0; if(res.max > 0) pct = (res.curr / res.max) * 100;
                if(pct>100) pct=100;
                vizHtml = `<div class="res-viz-bar" onclick="setResValue(${i})"><div class="res-bar-fill" style="width:${pct}%"></div></div>`;
            } else if (display === 'bubble') {
                let bubbles = '';
                for(let b=0; b<res.max; b++) {
                    const filled = b < res.curr ? 'filled' : '';
                    bubbles += `<div class="res-bubble-item ${filled}" onclick="toggleResBubble(${i}, ${b})"></div>`;
                }
                vizHtml = `<div class="res-viz-bubbles">${bubbles}</div>`;
            }

            return `
            <div class="resource-row">
                <div class="res-top">
                    <input type="text" class="res-name" placeholder="Resource Name" value="${res.name}" onchange="updateRes(${i}, 'name', this.value)">
                    <select class="res-style-select" onchange="updateRes(${i}, 'display', this.value)">
                        <option value="none" ${display==='none'?'selected':''}>None</option>
                        <option value="bubble" ${display==='bubble'?'selected':''}>Bubbles</option>
                        <option value="bar" ${display==='bar'?'selected':''}>Bar</option>
                    </select>
                    <button class="btn-del-res" onclick="delRes(${i})">&times;</button>
                </div>
                <div class="res-controls-row">
                    <button class="btn-res-mod btn-res-minus" onclick="modifyRes(${i}, -1)">-</button>
                    <input type="number" class="res-val" value="${res.curr}" onchange="updateRes(${i}, 'curr', this.value)">
                    <span class="res-sep">/</span>
                    <input type="number" class="res-val" value="${res.max}" onchange="updateRes(${i}, 'max', this.value)">
                    <button class="btn-res-mod btn-res-plus" onclick="modifyRes(${i}, 1)">+</button>
                </div>
                ${vizHtml}
                <div class="res-bottom">
                    <select class="res-reset-select" onchange="updateRes(${i}, 'rest', this.value)">
                        <option value="none" ${rest==='none'?'selected':''}>Manual Reset</option>
                        <option value="sr" ${rest==='sr'?'selected':''}>Reset: Short Rest</option>
                        <option value="lr" ${rest==='lr'?'selected':''}>Reset: Long Rest</option>
                    </select>
                    <label style="display:flex; align-items:center; gap:4px; margin:0 8px; font-size:1.2rem; cursor:pointer;" title="Enable Dice Recharge">
                        üé≤ <input type="checkbox" ${res.rCheck ? 'checked' : ''} onchange="updateRes(${i}, 'rCheck', this.checked)">
                    </label>
                    ${res.rCheck ? `
                        <input type="text" style="width:60px !important; height:35px; text-align:center;" placeholder="1d6" value="${res.rFormula||'1d6'}" onchange="updateRes(${i}, 'rFormula', this.value)">
                        <button class="btn-res-roll" onclick="rollResRecharge(${i})">Recharge</button>
                    ` : ''}
                </div>
            </div>
        `}).join('');
    }

    // --- DATA HELPERS ---
    function rollCheck(stat) { rollDie(20, getMod(data.stats[stat].val), stat.toUpperCase() + " Check", true, 'check'); }
    function rollSave(stat) { 
        const pb = getPB(data.meta.level);
        const mod = getMod(data.stats[stat].val);
        const totalBonus = mod + (data.stats[stat].save ? pb : 0);
        rollDie(20, totalBonus, stat.toUpperCase() + " Save", true, 'save'); 
    }
    
    // UPDATED: Roll Skill with Overrides
    function rollSkill(skill) {
        const defaultStat = skillsMap[skill];
        const activeStat = (data.skillOverrides && data.skillOverrides[skill]) ? data.skillOverrides[skill] : defaultStat;
        
        const pb = getPB(data.meta.level);
        const mod = getMod(data.stats[activeStat].val);
        const profLevel = data.skills[skill] || 0;
    
        // NEW: Add Misc Bonus
        const misc = getSkillMiscBonus(skill);
        const miscRaw = (data.skillMisc && data.skillMisc[skill]) ? data.skillMisc[skill] : "";
    
        let label = `${skill.charAt(0).toUpperCase() + skill.slice(1)} (${activeStat.toUpperCase()})`;
        if (misc !== 0) {
            // If it's a stat name, add that to label
            if(stats.includes(miscRaw)) label += ` + ${miscRaw.toUpperCase()}`;
            else label += ` + Bonus`;
        }
    
        rollDie(20, mod + (profLevel * pb) + misc, label, true, 'check');
    }
    
    function rollAttack(idx) {
        const atk = data.attacks[idx];
        const pb = getPB(data.meta.level);
        let mod = 0;
        if (atk.stat !== 'none') { mod = getMod(data.stats[atk.stat].val); }
        rollDie(20, mod + pb, (atk.name || 'Weapon') + " Atk", true, 'atk', atk.desc);
    }
    
    function updateStat(stat, val) { data.stats[stat].val = parseInt(val) || 0; save(); updateAll(); }
    function toggleSave(stat, e) { 
        if(e.target.tagName !== 'INPUT') { data.stats[stat].save = !data.stats[stat].save; save(); renderStats(); updateAll(); } 
        else { data.stats[stat].save = e.target.checked; save(); updateAll(); }
    }
    function cycleSkill(skill) { data.skills[skill] = ( (data.skills[skill] || 0) + 1) % 3; save(); renderSkills(); updateAll(); }
    
    // UPDATED: Cycle Skill Attribute
    function cycleSkillAttr(skill) {
        if (!data.skillOverrides) data.skillOverrides = {};
    
        // Get current stat
        const defaultStat = skillsMap[skill];
        const current = data.skillOverrides[skill] || defaultStat;
    
        // Find next stat in the list
        const idx = stats.indexOf(current);
        const nextIdx = (idx + 1) % stats.length;
        const nextStat = stats[nextIdx];
    
        // If next is the default, remove the override to save data space
        if (nextStat === defaultStat) {
            delete data.skillOverrides[skill];
        } else {
            data.skillOverrides[skill] = nextStat;
        }
    
        save(); 
        renderSkills(); 
        updateAll(); // Recalculate bonuses
    }
    
    function updateSpellMax(idx, val) {
        data.spells[idx].max = parseInt(val) || 0;
        if(data.spells[idx].used > data.spells[idx].max) data.spells[idx].used = data.spells[idx].max;
        save(); renderSpells();
    }
    function toggleSpellSlot(idx, bubbleIdx) {
        const currentUsed = data.spells[idx].used;
        if (bubbleIdx + 1 === currentUsed) { data.spells[idx].used = bubbleIdx; } else { data.spells[idx].used = bubbleIdx + 1; }
        save(); renderSpells();
    }
    
    function addAttack() { data.attacks.push({ name: '', stat: 'str', dmg: '1d8', desc: '' }); save(); renderAttacks(); }
    function updateAttack(idx, field, val) { data.attacks[idx][field] = val; save(); }
    function delAttack(idx) { data.attacks.splice(idx, 1); save(); renderAttacks(); }
    
    function addFeature() { data.features.push({ name: '', desc: '' }); save(); renderFeatures(); }
    function updateFeature(idx, field, val) { data.features[idx][field] = val; save(); }
    function delFeature(idx) { data.features.splice(idx, 1); save(); renderFeatures(); }
    function postFeature(idx) {
        const feat = data.features[idx];
        const name = feat.name || "Unnamed Feature";
        const desc = feat.desc || "";
        showLog(name.substr(0,10), "Posted");
        sendToDiscord(name, desc, "Feature", 'feature');
    }

    function addResource() { data.resources.push({ name: '', curr: 0, max: 0, rest: 'none', display: 'none', rCheck: false, rFormula: '1d6' }); save(); renderResources(); }
    function updateRes(i, field, val) { 
        if(field === 'curr' || field === 'max') val = parseInt(val) || 0;
        if(field === 'rCheck') val = val; 
        data.resources[i][field] = val; save(); renderResources(); 
    }
    function modifyRes(i, delta) {
        const res = data.resources[i]; const newVal = res.curr + delta;
        res.curr = Math.max(0, Math.min(res.max, newVal)); save(); renderResources();
    }
    function setResValue(i) {
        const res = data.resources[i]; const val = prompt("Set value for " + (res.name||'Resource') + ":", res.curr);
        if(val !== null) { const parsed = parseInt(val); if(!isNaN(parsed)) { res.curr = Math.max(0, Math.min(res.max, parsed)); save(); renderResources(); } }
    }
    function delRes(i) { data.resources.splice(i, 1); save(); renderResources(); }
    function toggleResBubble(i, bubbleIdx) {
        const currentUsed = data.resources[i].curr;
        if (bubbleIdx + 1 === currentUsed) { data.resources[i].curr = bubbleIdx; } else { data.resources[i].curr = bubbleIdx + 1; }
        save(); renderResources();
    }
    function rollResRecharge(i) {
        const res = data.resources[i]; const formula = res.rFormula || '1d6';
        const regex = /^(\d+)?d(\d+)\s*([+-]\s*\d+)?$/i;
        const match = formula.match(regex);
        if(!match) { showLog("Err", "Formula"); return; }
        const count = parseInt(match[1]) || 1; const sides = parseInt(match[2]);
        const modStr = match[3] ? match[3].replace(/\s/g, '') : "+0"; const mod = parseInt(modStr);
        const result = coreRoll(count, sides); const total = result.total + mod;
        res.curr = Math.min(res.max, res.curr + total);
        save(); renderResources();
        showLog(`Recharge ${formula}`, total);
        sendToDiscord(`Recharge: ${res.name}`, `Rolled ${formula}: ${result.formula}${modStr}`, `**+${total}** (Curr: ${res.curr})`, 'check');
    }

    function toggleDiscord(active) {
        data.meta.discordActive = active;
        const label = document.getElementById('discordLabel');
        if(active) label.classList.add('discord-active'); else label.classList.remove('discord-active');
        save();
    }
    
    function sendToDiscord(label, formulaStr, result, type = 'check', customDesc = '') {
        if (!data.meta.discordActive || !data.meta.webhook) return;
        let color = 5164484; 
        if (type === 'atk') color = 16739179; 
        if (type === 'dmg') color = 9807270; 
        if (type === 'save') color = 3066993; 
        if (type === 'feature') color = 3447003; 
        
        let descText = "";
        if(type === 'feature') { descText = formulaStr; } 
        else { descText = `**Result:** ${result}\n\n${formulaStr}`; if (customDesc) descText = `*${customDesc}*\n\n` + descText; }

        const isDeathSave = (label === "Death Save");
        if (secretMode || isDeathSave) { descText = `|| ${descText} ||`; }

        const payload = { embeds: [{ author: { name: data.meta.name || "Character" }, title: label, description: descText, color: color, footer: { text: `Player: ${data.meta.player}` } }] };
        fetch(data.meta.webhook, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }).catch(err => console.error(err));
    }
    
    function showIoMsg(txt) { 
        const msg = document.getElementById('ioMsg'); msg.innerText = txt; setTimeout(() => msg.innerText = "", 3000); 
    }

    async function exportData() {
        save();
        try {
            const jsonStr = JSON.stringify(allData);
            const stream = new Blob([jsonStr]).stream();
            const compressedStream = stream.pipeThrough(new CompressionStream("gzip"));
            const compressedResponse = new Response(compressedStream);
            const blob = await compressedResponse.blob();
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result.split(',')[1];
                const field = document.getElementById('ioField'); 
                field.value = base64; field.select(); field.setSelectionRange(0, 99999);
                navigator.clipboard.writeText(base64).then(() => showIoMsg("Compressed & Copied!"));
            };
            reader.readAsDataURL(blob);
        } catch(e) { console.error(e); showIoMsg("Export Failed"); }
    }

    async function importData() {
        if (!confirm("Load data? This overwrites ALL characters.")) return;
        const field = document.getElementById('ioField'); 
        const b64 = field.value.trim();
        if(!b64) return showIoMsg("Empty!");
        
        try {
            const binString = atob(b64);
            const bytes = Uint8Array.from(binString, c => c.charCodeAt(0));
            const stream = new Blob([bytes]).stream();
            const decompressedStream = stream.pipeThrough(new DecompressionStream("gzip"));
            const resp = new Response(decompressedStream);
            const json = await resp.json(); 
            
            if (json.activeId && json.characters) {
                allData = json;
            } else {
                const id = 'char_imported_' + Date.now();
                allData = { activeId: id, characters: {} };
                allData.characters[id] = json;
            }
            
            saveGlobal(); 
            loadActiveChar(); 
            field.value = ""; 
            showIoMsg("Data Loaded!");
            
        } catch(e) { 
            console.error(e);
            try {
                 const oldJson = decodeURIComponent(atob(b64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
                 const parsed = JSON.parse(oldJson);
                 if (parsed.activeId && parsed.characters) {
                     allData = parsed;
                 } else {
                     const id = 'char_legacy_' + Date.now();
                     allData = { activeId: id, characters: {} };
                     allData.characters[id] = parsed;
                 }
                 saveGlobal(); loadActiveChar(); field.value = "";
                 showIoMsg("Restored Old Save");
            } catch(err2) {
                showIoMsg("Invalid Data");
            }
        }
    }

    // --- DRAG AND DROP ---
    let swapSourceCard = null;
    function setupDragAndDrop() {
        const grips = document.querySelectorAll('.drag-grip');
        let draggedCard = null; let initialY = 0; let initialRect = null; let placeholder = null;

        grips.forEach(grip => {
            grip.addEventListener('dblclick', (e) => { e.preventDefault(); e.stopPropagation(); handleSwapInteraction(grip.closest('.card')); });
            grip.addEventListener('pointerdown', (e) => {
                if (e.button !== 0 && e.pointerType === 'mouse') return;
                const card = grip.parentElement; draggedCard = card;
                placeholder = document.createElement('div'); placeholder.className = 'card placeholder';
                placeholder.style.height = card.offsetHeight + 'px'; placeholder.style.background = 'transparent'; placeholder.style.border = '2px dashed #333';
                initialRect = card.getBoundingClientRect(); initialY = e.clientY;
                card.style.width = initialRect.width + 'px'; card.classList.add('dragging');
                card.parentNode.insertBefore(placeholder, card);
                card.style.position = 'fixed'; card.style.top = initialRect.top + 'px'; card.style.left = initialRect.left + 'px';
                grip.setPointerCapture(e.pointerId);
                grip.addEventListener('pointermove', onPointerMove); grip.addEventListener('pointerup', onPointerUp); grip.addEventListener('pointercancel', onPointerUp);
            });
            function onPointerMove(e) {
                if (!draggedCard) return; e.preventDefault();
                const dy = e.clientY - initialY; draggedCard.style.transform = `translateY(${dy}px)`;
                const container = document.querySelector('.sheet-container');
                const siblings = [...container.querySelectorAll('.card:not(.dragging)')];
                const nextSibling = siblings.find(sibling => {
                    const rect = sibling.getBoundingClientRect(); const midY = rect.top + rect.height / 2; return e.clientY < midY;
                });
                container.insertBefore(placeholder, nextSibling);
            }
            function onPointerUp(e) {
                if (!draggedCard) return;
                grip.removeEventListener('pointermove', onPointerMove); grip.removeEventListener('pointerup', onPointerUp); grip.removeEventListener('pointercancel', onPointerUp);
                grip.releasePointerCapture(e.pointerId);
                draggedCard.classList.remove('dragging'); draggedCard.style.position = ''; draggedCard.style.top = ''; draggedCard.style.left = ''; draggedCard.style.width = ''; draggedCard.style.transform = '';
                if (placeholder && placeholder.parentNode) { placeholder.parentNode.insertBefore(draggedCard, placeholder); placeholder.remove(); }
                draggedCard = null; placeholder = null; saveCardOrder();
            }
        });
    }
    function handleSwapInteraction(card) {
        if (swapSourceCard === null) { swapSourceCard = card; card.classList.add('swap-active'); showLog("Swap Mode", "Select Another"); } 
        else if (swapSourceCard === card) { swapSourceCard.classList.remove('swap-active'); swapSourceCard = null; showLog("Swap Mode", "Cancelled"); } 
        else {
            const container = document.querySelector('.sheet-container');
            const placeholderA = document.createElement('div'); const placeholderB = document.createElement('div');
            container.insertBefore(placeholderA, swapSourceCard); container.insertBefore(placeholderB, card);
            container.insertBefore(swapSourceCard, placeholderB); container.insertBefore(card, placeholderA);
            placeholderA.remove(); placeholderB.remove();
            swapSourceCard.classList.remove('swap-active'); swapSourceCard = null; saveCardOrder(); showLog("Layout", "Swapped");
        }
    }
    function saveCardOrder() {
        const container = document.querySelector('.sheet-container');
        const order = Array.from(container.children).filter(c => c.id && c.classList.contains('card')).map(c => c.id);
        data.uiState.cardOrder = order; save();
    }

    init();
</script>
</body>
</html>





